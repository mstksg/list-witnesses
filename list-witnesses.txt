-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/mstksg/list-witnesses#readme</a>
@package list-witnesses
@version 0.1.0.0

module Data.Type.List.Prod

-- | This shows up in many places in the Haskell ecosystem: it's vinyl, or
--   a heterogeneous list parameterized by a functor.
--   
--   A value of type
--   
--   <pre>
--   <a>Prod</a> f '[a,b,c]
--   </pre>
--   
--   contains an <tt>f a</tt>, and <tt>f b</tt>, and an <tt>f c</tt>.
data Prod :: (k -> Type) -> [k] -> Type
[Ø] :: Prod f '[]
[:<] :: f a -> Prod f as -> Prod f (a : as)
infixr 5 :<

-- | Alias for <a>Ø</a>
pNil :: Prod f '[]

-- | Retrieve an element in a <a>Prod</a> at a given index.
indexProd :: Index as x -> Prod f as -> f x

-- | A type-preserving lens into a value in a <a>Prod</a>, given a
--   <a>Index</a> indicating which value. This lens cannot change the type
--   of the value, unlike "Data.Type.List.Edit.lensProd'.
--   
--   Read this type signature as:
--   
--   <pre>
--   <tt>lensProd</tt>
--       :: <a>Index</a> as x
--       -&gt; Lens' (<a>Prod</a> g as) (g x)
--   </pre>
lensProd' :: forall as x g f. Functor f => Index as x -> (g x -> f (g x)) -> Prod g as -> f (Prod g as)

module Data.Type.List.Edit

-- | An <tt><a>Insert</a> as bs x</tt> is a witness that you can insert
--   <tt>x</tt> into some position in list <tt>as</tt> to produce list
--   <tt>bs</tt>.
--   
--   Some examples:
--   
--   <pre>
--   InsZ                   :: Insert '[1,2,3] '[4,1,2,3] 4
--   InsS InsZ              :: Insert '[1,2,3] '[1,4,2,3] 4
--   InsS (InsS InsZ)       :: Insert '[1,2,3] '[1,2,4,3] 4
--   InsS (InsS (InsS InsZ) :: Insert '[1,2,3] '[1,2,3,4] 4
--   </pre>
data Insert :: [k] -> [k] -> k -> Type
[InsZ] :: Insert as (x : as) x
[InsS] :: Insert as bs x -> Insert (a : as) (a : bs) x

-- | A <tt><a>Delete</a> as bs x</tt> is a witness that you can delete item
--   <tt>x</tt> from <tt>as</tt> to produce the list <tt>bs</tt>. It is
--   essentially <a>Insert</a> flipped.
--   
--   Some examples:
--   
--   <pre>
--   DelZ             :: Delete '[1,2,3] '[2,3] 1
--   DelS DelZ        :: Delete '[1,2,3] '[2,3] 2
--   DelS (DelS DelZ) :: Delete '[1,2,3] '[1,2] 3
--   </pre>
data Delete :: [k] -> [k] -> k -> Type
[DelZ] :: Delete (x : as) as x
[DelS] :: Delete as bs x -> Delete (a : as) (a : bs) x
insToDel :: Insert as bs x -> Delete bs as x

-- | Flip a deletion
delToIns :: Delete as bs x -> Insert bs as x

-- | A <tt><a>Substitute</a> as bs x y</tt> is a witness that you can
--   replace item <tt>x</tt> in <tt>as</tt> with item <tt>y</tt> to produce
--   <tt>bs</tt>.
--   
--   Some examples:
--   
--   <pre>
--   SubZ             :: Substitute '[1,2,3] '[4,2,3] 1 4
--   SubS SubZ        :: Substitute '[1,2,3] '[1,4,3] 2 4
--   SubS (SubS SubZ) :: Substitute '[1,2,3] '[1,2,4] 3 4
--   </pre>
data Substitute :: [k] -> [k] -> k -> k -> Type
[SubZ] :: Substitute (x : as) (y : as) x y
[SubS] :: Substitute as bs x y -> Substitute (c : as) (c : bs) x y

-- | Flip a substitution
flipSub :: Substitute as bs x y -> Substitute bs as y x

-- | An <tt><a>Edit</a> as bs</tt> is an edit script transforming
--   <tt>as</tt> into <tt>bs</tt> through successive insertions, deletions,
--   and substitutions.
data Edit :: [k] -> [k] -> Type
[ENil] :: Edit as as
[EIns] :: Insert bs cs x -> Edit as bs -> Edit as cs
[EDel] :: Delete bs cs x -> Edit as bs -> Edit as cs
[ESub] :: Substitute bs cs x y -> Edit as bs -> Edit as cs

-- | Reverse an <a>Edit</a> script. O(n^2).
flipEdit :: Edit as bs -> Edit bs as

-- | Insert a value into a <a>Prod</a>, at a position indicated by the
--   <a>Insert</a>.
insertProd :: Insert as bs x -> f x -> Prod f as -> Prod f bs

-- | Delete a value in a <a>Prod</a>, at a position indicated by the
--   <a>Delete</a>.
deleteProd :: Delete as bs x -> Prod f as -> Prod f bs

-- | Retrieve and delete a value in a <a>Prod</a>, at a position indicated
--   by the <a>Delete</a>.
deleteGetProd :: Delete as bs x -> Prod f as -> (f x, Prod f bs)

-- | A type-changing lens into a value in a <a>Prod</a>, given a
--   <a>Substitute</a> indicating which value. This lens can change the
--   type of the value, unlike <a>lensProd'</a>.
--   
--   Read this type signature as:
--   
--   <pre>
--   <a>lensProd</a>
--       :: <a>Substitute</a> as bs x y
--       -&gt; Lens (<a>Prod</a> g as) (Prod g bs) (g x) (g y)
--   </pre>
lensProd :: forall as bs x y g f. Functor f => Substitute as bs x y -> (g x -> f (g y)) -> Prod g as -> f (Prod g bs)

-- | Substitute a value in a <a>Prod</a> at a given position, indicated by
--   the <a>Substitute</a>. This is essentially a specialized version of
--   <a>lensProd</a>.
substituteProd :: Substitute as bs x y -> (f x -> f y) -> Prod f as -> Prod f bs

-- | If you add an item to <tt>as</tt> to create <tt>bs</tt>, you also need
--   to shift an <tt><a>Index</a> as y</tt> to <tt>Index bs y</tt>. This
--   shifts the <a>Index</a> in <tt>as</tt> to become an <a>Index</a> in
--   <tt>bs</tt>, but makes sure that the index points to the same original
--   value.
shiftIndex :: Insert as bs x -> Index as y -> Index bs y

-- | Used as the return type of <a>unshiftIndex</a>. An
--   <tt><a>Unshifted</a> bs x y</tt> is like a <tt><a>Maybe</a>
--   (<a>Index</a> bs y)</tt>, except the <a>Nothing</a> case witnesses
--   that <tt>x ~ y</tt>.
data Unshifted :: [k] -> k -> k -> Type
[GotDeleted] :: Unshifted bs x x
[NotDeleted] :: Index bs y -> Unshifted bs x y

-- | If you delete an item in <tt>as</tt> to create <tt>bs</tt>, you also
--   need to move <tt><a>Index</a> as y</tt> into <tt>Index bs y</tt>. This
--   transforms the <a>Index</a> in <tt>as</tt> to become an <a>Index</a>
--   in <tt>bs</tt>, making sure the index points to the same original
--   value.
--   
--   However, there is a possibility that the deleted item is the item that
--   the index was originally pointing to. If this is the case, this
--   function returns <a>GotDeleted</a>, a witness that <tt>x ~ y</tt>.
--   Otherwise, it returns <a>NotDeleted</a> with the unshifted index.
unshiftIndex :: Delete as bs x -> Index as y -> Unshifted bs x y

-- | A version of <a>unshiftIndex</a> returning a simple <a>Maybe</a>. This
--   can be used if you don't care about witnessing that <tt>x ~ y</tt> in
--   the case that the index is the item that is deleted.
unshiftIndex_ :: Delete as bs x -> Index as y -> Maybe (Index bs y)

-- | Used as the return type of <a>reshiftIndex</a>. An
--   <tt><a>Reshifted</a> bs x y z</tt> is like an <tt><a>Either</a>
--   (<a>Index</a> bs y) (<a>Index</a> bs z)</tt>, except the <a>Left</a>
--   case witnesses that <tt>x ~ z</tt>.
data Reshifted :: [k] -> k -> k -> k -> Type
[GotSubbed] :: Index bs y -> Reshifted bs z y z
[NotSubbed] :: Index bs z -> Reshifted bs x y z

-- | If you substitute an item in <tt>as</tt> to create <tt>bs</tt>, you
--   also need to reshift <tt><a>Index</a> as z</tt> into <tt><a>Index</a>
--   bs z</tt>. This reshifts the <a>Index</a> in <tt>as</tt> to become an
--   <a>Index</a> in <tt>bs</tt>, making sure the index points to the same
--   original value.
--   
--   However, there is a possibility that the substituted item is the item
--   that the index was originally pointing to. If this is the case, this
--   function returns <a>GotSubbed</a>, a witness that <tt>x ~ z</tt>.
--   Otherwise, it returns <a>NotSubbed</a>. Both contain the updated
--   index.
reshiftIndex :: Substitute as bs x y -> Index as z -> Reshifted bs x y z

-- | A version of <a>reshiftIndex</a> returning a simple <a>Either</a>.
--   This can be the case if you don't care about witnessing <tt>x ~ z</tt>
--   in the case that the index is the item that was substituted.
reshiftIndex_ :: Substitute as bs x y -> Index as z -> Either (Index bs y) (Index bs z)
instance forall k (as :: [k]) (bs :: [k]) (x :: k). GHC.Show.Show (Data.Type.List.Edit.Insert as bs x)
instance forall k (as :: [k]) (bs :: [k]) (x :: k). GHC.Show.Show (Data.Type.List.Edit.Delete as bs x)
instance forall k (as :: [k]) (bs :: [k]) (x :: k) (y :: k). GHC.Show.Show (Data.Type.List.Edit.Substitute as bs x y)
instance forall k (as :: [k]) (bs :: [k]). GHC.Show.Show (Data.Type.List.Edit.Edit as bs)
instance forall k (bs :: [k]) (x :: k) (y :: k). GHC.Show.Show (Data.Type.List.Edit.Unshifted bs x y)
instance Control.Category.Category Data.Type.List.Edit.Edit

module Data.Type.List.Sublist

-- | A <tt><a>Prefix</a> as bs</tt> witnesses that <tt>as</tt> is a prefix
--   of <tt>bs</tt>.
--   
--   Some examples:
--   
--   <pre>
--   PreZ                    :: Prefix '[]      '[1,2,3]
--   PreS PreZ               :: Prefix '[1]     '[1,2,3]
--   PreS (PreS PreZ)        :: Prefix '[1,2]   '[1,2,3]
--   PreS (PreS (PreS PreZ)) :: Prefix '[1,2,3] '[1,2,3]
--   </pre>
--   
--   Rule of thumb for construction: the number of <a>PreS</a> is the
--   number of items in the prefix.
data Prefix :: [k] -> [k] -> Type
[PreZ] :: Prefix '[] as
[PreS] :: Prefix as bs -> Prefix (a : as) (a : bs)

-- | A <tt><a>Suffix</a> as bs</tt> witnesses that <tt>as</tt> is a suffix
--   of <tt>bs</tt>.
--   
--   Some examples:
--   
--   <pre>
--   SufZ                      :: Suffix '[1,2,3] '[1,2,3]
--   SufS SufZ                 :: Suffix   '[2,3] '[1,2,3]
--   SufS (SufS SufZ)          :: Suffix     '[3] '[1,2,3]
--   SufS (SufS (SufS (SufZ))) :: Suffix      '[] '[1,2,3]
--   </pre>
--   
--   Rule of thumb for construction: the number of <a>SufS</a> is the
--   number of items to "drop" before getting the suffix.
data Suffix :: [k] -> [k] -> Type
[SufZ] :: Suffix as as
[SufS] :: Suffix as bs -> Suffix as (b : bs)

-- | Take items from a <a>Prod</a> corresponding to a given <a>Prefix</a>.
takeProd :: Prefix as bs -> Prod f bs -> Prod f as

-- | Drop items from a <a>Prod</a> corresponding to a given <a>Suffix</a>.
dropProd :: Suffix as bs -> Prod f bs -> Prod f as
instance forall k (as :: [k]) (bs :: [k]). GHC.Show.Show (Data.Type.List.Sublist.Prefix as bs)
instance forall k (as :: [k]) (bs :: [k]). GHC.Show.Show (Data.Type.List.Sublist.Suffix as bs)
