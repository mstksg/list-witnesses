-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Witnesses for working with type-level lists
--   
--   Collection of assorted inductive witnesses and functions for working
--   with type-level lists.
--   
--   <ul>
--   <li>*Data.Type.List.Edit* contains single-item edits of lists,
--   including insertion, deletion, and substitution.</li>
--   <li>*Data.Type.List.Sublist* contains witnesses for prefixes,
--   suffixes, and two-way splits of type-level lists.</li>
--   </ul>
@package list-witnesses
@version 0.1.0.0


-- | Witnesses regarding single-item edits of lists.
module Data.Type.List.Edit

-- | An <tt><a>Insert</a> as bs x</tt> is a witness that you can insert
--   <tt>x</tt> into some position in list <tt>as</tt> to produce list
--   <tt>bs</tt>. It is essentially <a>Delete</a> flipped.
--   
--   Some examples:
--   
--   <pre>
--   InsZ                   :: Insert '[1,2,3] '[4,1,2,3] 4
--   InsS InsZ              :: Insert '[1,2,3] '[1,4,2,3] 4
--   InsS (InsS InsZ)       :: Insert '[1,2,3] '[1,2,4,3] 4
--   InsS (InsS (InsS InsZ) :: Insert '[1,2,3] '[1,2,3,4] 4
--   </pre>
--   
--   <tt>bs</tt> will always be exactly one item longer than <tt>as</tt>.
data Insert :: [k] -> [k] -> k -> Type
[InsZ] :: Insert as (x : as) x
[InsS] :: Insert as bs x -> Insert (a : as) (a : bs) x

-- | A <tt><a>Delete</a> as bs x</tt> is a witness that you can delete item
--   <tt>x</tt> from <tt>as</tt> to produce the list <tt>bs</tt>. It is
--   essentially <a>Insert</a> flipped.
--   
--   Some examples:
--   
--   <pre>
--   DelZ             :: Delete '[1,2,3] '[2,3] 1
--   DelS DelZ        :: Delete '[1,2,3] '[2,3] 2
--   DelS (DelS DelZ) :: Delete '[1,2,3] '[1,2] 3
--   </pre>
--   
--   <tt>bs</tt> will always be exactly one item shorter than <tt>as</tt>.
data Delete :: [k] -> [k] -> k -> Type
[DelZ] :: Delete (x : as) as x
[DelS] :: Delete as bs x -> Delete (a : as) (a : bs) x

-- | Flip an insertion.
insToDel :: Insert as bs x -> Delete bs as x

-- | Flip a deletion.
delToIns :: Delete as bs x -> Insert bs as x

-- | A <tt><a>Substitute</a> as bs x y</tt> is a witness that you can
--   replace item <tt>x</tt> in <tt>as</tt> with item <tt>y</tt> to produce
--   <tt>bs</tt>.
--   
--   Some examples:
--   
--   <pre>
--   SubZ             :: Substitute '[1,2,3] '[4,2,3] 1 4
--   SubS SubZ        :: Substitute '[1,2,3] '[1,4,3] 2 4
--   SubS (SubS SubZ) :: Substitute '[1,2,3] '[1,2,4] 3 4
--   </pre>
data Substitute :: [k] -> [k] -> k -> k -> Type
[SubZ] :: Substitute (x : as) (y : as) x y
[SubS] :: Substitute as bs x y -> Substitute (c : as) (c : bs) x y

-- | Flip a substitution
flipSub :: Substitute as bs x y -> Substitute bs as y x

-- | Decompose a <a>Substitute</a> into a <a>Delete</a> followed by an
--   <a>Insert</a>.
subToDelIns :: Substitute as bs x y -> (forall cs. Delete as cs x -> Insert cs bs y -> r) -> r

-- | Kind-indexed singleton for <a>Insert</a>.
data SInsert as bs x :: Insert as bs x -> Type
[SInsZ] :: SInsert as (x : as) x  'InsZ
[SInsS] :: SInsert as bs x ins -> SInsert (a : as) (a : bs) x ( 'InsS ins)

-- | Kind-indexed singleton for <a>Delete</a>.
data SDelete as bs x :: Delete as bs x -> Type
[SDelZ] :: SDelete (x : as) as x  'DelZ
[SDelS] :: SDelete as bs x del -> SDelete (a : as) (a : bs) x ( 'DelS del)

-- | Kind-indexed singleton for <a>Substitute</a>.
data SSubstitute as bs x y :: Substitute as bs x y -> Type
[SSubZ] :: SSubstitute (x : as) (y : as) x y  'SubZ
[SSubS] :: SSubstitute as bs x y sub -> SSubstitute (c : as) (c : bs) x y ( 'SubS sub)

-- | An <tt><a>Edit</a> as bs</tt> is a reversible edit script transforming
--   <tt>as</tt> into <tt>bs</tt> through successive insertions, deletions,
--   and substitutions.
--   
--   TODO: implement Wagner-Fischer to minimize find a minimal edit
--   distance
data Edit :: [k] -> [k] -> Type
[ENil] :: Edit as as
[EIns] :: Insert bs cs x -> Edit as bs -> Edit as cs
[EDel] :: Delete bs cs x -> Edit as bs -> Edit as cs
[ESub] :: Substitute bs cs x y -> Edit as bs -> Edit as cs

-- | Compose two <a>Edit</a>s
compEdit :: Edit as bs -> Edit bs cs -> Edit as cs

-- | Reverse an <a>Edit</a> script. O(n^2). Please do not use.
--   
--   TODO: Make O(n) using diff lists.
flipEdit :: Edit as bs -> Edit bs as

-- | Insert a value into a <a>Rec</a>, at a position indicated by the
--   <a>Insert</a>.
insertRec :: Insert as bs x -> f x -> Rec f as -> Rec f bs

-- | Delete a value in a <a>Rec</a>, at a position indicated by the
--   <a>Delete</a>.
deleteRec :: Delete as bs x -> Rec f as -> Rec f bs

-- | Retrieve and delete a value in a <a>Rec</a>, at a position indicated
--   by the <a>Delete</a>.
deleteGetRec :: Delete as bs x -> Rec f as -> (f x, Rec f bs)

-- | A type-changing lens into a value in a <a>Rec</a>, given a
--   <a>Substitute</a> indicating which value.
--   
--   Read this type signature as:
--   
--   <pre>
--   <a>recLens</a>
--       :: <a>Substitute</a> as bs x y
--       -&gt; Lens (<a>Rec</a> f as) (Rec f bs) (f x) (f y)
--   </pre>
--   
--   For example:
--   
--   <pre>
--   recLens (SubS SubZ)
--        :: Lens (Rec f '[a,b,c,d]) (Rec f '[a,e,c,d])
--                (f b)              (f e)
--   </pre>
--   
--   The number of <a>SubS</a> in the index essentially indicates the index
--   to edit at.
--   
--   This is similar to <tt>rlensC</tt> from <i>vinyl</i>, but is built
--   explicitly and inductively, instead of using typeclass magic.
recLens :: forall as bs x y g f. Functor f => Substitute as bs x y -> (g x -> f (g y)) -> Rec g as -> f (Rec g bs)

-- | Substitute a value in a <a>Rec</a> at a given position, indicated by
--   the <a>Substitute</a>. This is essentially a specialized version of
--   <a>recLens</a>.
substituteRec :: Substitute as bs x y -> (f x -> f y) -> Rec f as -> Rec f bs

-- | If you add an item to <tt>as</tt> to create <tt>bs</tt>, you also need
--   to shift an <tt><a>Index</a> as y</tt> to <tt>Index bs y</tt>. This
--   shifts the <a>Index</a> in <tt>as</tt> to become an <a>Index</a> in
--   <tt>bs</tt>, but makes sure that the index points to the same original
--   value.
insertIndex :: Insert as bs x -> Index as y -> Index bs y

-- | Used as the return type of <a>deleteIndex</a>. An <tt><a>DeletedIx</a>
--   bs x y</tt> is like a <tt><a>Maybe</a> (<a>Index</a> bs y)</tt>,
--   except the <a>Nothing</a> case witnesses that <tt>x ~ y</tt>.
data DeletedIx :: [k] -> k -> k -> Type
[GotDeleted] :: DeletedIx bs x x
[NotDeleted] :: Index bs y -> DeletedIx bs x y

-- | If you delete an item in <tt>as</tt> to create <tt>bs</tt>, you also
--   need to move <tt><a>Index</a> as y</tt> into <tt>Index bs y</tt>. This
--   transforms the <a>Index</a> in <tt>as</tt> to become an <a>Index</a>
--   in <tt>bs</tt>, making sure the index points to the same original
--   value.
--   
--   However, there is a possibility that the deleted item is the item that
--   the index was originally pointing to. If this is the case, this
--   function returns <a>GotDeleted</a>, a witness that <tt>x ~ y</tt>.
--   Otherwise, it returns <a>NotDeleted</a> with the unshifted index.
deleteIndex :: Delete as bs x -> Index as y -> DeletedIx bs x y

-- | A version of <a>deleteIndex</a> returning a simple <a>Maybe</a>. This
--   can be used if you don't care about witnessing that <tt>x ~ y</tt> in
--   the case that the index is the item that is deleted.
deleteIndex_ :: Delete as bs x -> Index as y -> Maybe (Index bs y)

-- | Used as the return type of <a>substituteIndex</a>. An
--   <tt><a>SubstitutedIx</a> bs x y z</tt> is like an <tt><a>Either</a>
--   (<a>Index</a> bs y) (<a>Index</a> bs z)</tt>, except the <a>Left</a>
--   case witnesses that <tt>x ~ z</tt>.
data SubstitutedIx :: [k] -> k -> k -> k -> Type
[GotSubbed] :: Index bs y -> SubstitutedIx bs z y z
[NotSubbed] :: Index bs z -> SubstitutedIx bs x y z

-- | If you substitute an item in <tt>as</tt> to create <tt>bs</tt>, you
--   also need to reshift <tt><a>Index</a> as z</tt> into <tt><a>Index</a>
--   bs z</tt>. This reshifts the <a>Index</a> in <tt>as</tt> to become an
--   <a>Index</a> in <tt>bs</tt>, making sure the index points to the same
--   original value.
--   
--   However, there is a possibility that the substituted item is the item
--   that the index was originally pointing to. If this is the case, this
--   function returns <a>GotSubbed</a>, a witness that <tt>x ~ z</tt>.
--   Otherwise, it returns <a>NotSubbed</a>. Both contain the updated
--   index.
substituteIndex :: Substitute as bs x y -> Index as z -> SubstitutedIx bs x y z

-- | A version of <a>substituteIndex</a> returning a simple <a>Either</a>.
--   This can be the case if you don't care about witnessing <tt>x ~ z</tt>
--   in the case that the index is the item that was substituted.
substituteIndex_ :: Substitute as bs x y -> Index as z -> Either (Index bs y) (Index bs z)

-- | Given an <a>Index</a> pointing to an element, create a <a>Delete</a>
--   corresponding to the given item. The type of the resulting list is
--   existentially quantified, is guaranteed to be just exactly the
--   original list minus the specified element.
withDelete :: Index as x -> (forall bs. Delete as bs x -> r) -> r

-- | Given an <a>Index</a> pointing to an element, create an <a>Insert</a>
--   placing an item <i>directly before</i> the given element. The type is
--   existentailly quantified.
withInsert :: Index as x -> (forall bs. Insert as bs y -> r) -> r

-- | Given an <a>Index</a> pointing to an element, create an <a>Insert</a>
--   placing an item <i>directly after</i> the given element. The type is
--   existentailly quantified.
withInsertAfter :: Index as x -> (forall bs. Insert as bs y -> r) -> r
instance forall k (as :: [k]) (bs :: [k]) (x :: k). GHC.Show.Show (Data.Type.List.Edit.Insert as bs x)
instance forall a (as :: [a]) (bs :: [a]) (x :: a) (del :: Data.Type.List.Edit.Insert as bs x). GHC.Show.Show (Data.Type.List.Edit.SInsert as bs x del)
instance forall k (as :: [k]) (bs :: [k]) (x :: k). GHC.Show.Show (Data.Type.List.Edit.Delete as bs x)
instance forall a (as :: [a]) (bs :: [a]) (x :: a) (del :: Data.Type.List.Edit.Delete as bs x). GHC.Show.Show (Data.Type.List.Edit.SDelete as bs x del)
instance forall k (as :: [k]) (bs :: [k]) (x :: k) (y :: k). GHC.Show.Show (Data.Type.List.Edit.Substitute as bs x y)
instance forall k (as :: [k]) (bs :: [k]). GHC.Show.Show (Data.Type.List.Edit.Edit as bs)
instance forall k (bs :: [k]) (x :: k) (y :: k). GHC.Show.Show (Data.Type.List.Edit.DeletedIx bs x y)
instance Control.Category.Category Data.Type.List.Edit.Edit


-- | Witnesses regarding sublists of lists.
module Data.Type.List.Sublist

-- | A <tt><a>Prefix</a> as bs</tt> witnesses that <tt>as</tt> is a prefix
--   of <tt>bs</tt>.
--   
--   Some examples:
--   
--   <pre>
--   PreZ                    :: Prefix '[]      '[1,2,3]
--   PreS PreZ               :: Prefix '[1]     '[1,2,3]
--   PreS (PreS PreZ)        :: Prefix '[1,2]   '[1,2,3]
--   PreS (PreS (PreS PreZ)) :: Prefix '[1,2,3] '[1,2,3]
--   </pre>
--   
--   Rule of thumb for construction: the number of <a>PreS</a> is the
--   number of items in the prefix.
--   
--   This is essentially the first half of an <a>Append</a>, but is
--   conceptually easier to work with.
data Prefix :: [k] -> [k] -> Type
[PreZ] :: Prefix '[] as
[PreS] :: Prefix as bs -> Prefix (a : as) (a : bs)

-- | Take items from a <a>Rec</a> corresponding to a given <a>Prefix</a>.
takeRec :: Prefix as bs -> Rec f bs -> Rec f as

-- | A lens into the prefix of a <a>Rec</a>.
--   
--   Read this type signature as:
--   
--   <pre>
--   <a>prefixLens</a>
--       :: Prefix as bs
--       -&gt; Lens' (Rec f bs) (Rec f as)
--   </pre>
prefixLens :: forall as bs g f. Functor f => Prefix as bs -> (Rec g as -> f (Rec g as)) -> Rec g bs -> f (Rec g bs)

-- | Shave off the final inhabitants of an <a>Index</a>, keeping only
--   indices a part of a given prefix. If the index is out of range,
--   <a>Nothing</a> will be returned.
--   
--   This is essentially <a>splitIndex</a>, but taking only <a>Left</a>
--   results.
takeIndex :: Prefix as bs -> Index bs x -> Maybe (Index as x)

-- | An index pointing to a given item in a prefix is also an index
--   pointing to the same item in the full list. This "weakens" the bounds
--   of an index, widening the list at the end but preserving the original
--   index. This is the inverse of <a>takeIndex</a>.
weakenIndex :: Prefix as bs -> Index as x -> Index bs x

-- | A <tt><a>Suffix</a> as bs</tt> witnesses that <tt>as</tt> is a suffix
--   of <tt>bs</tt>.
--   
--   Some examples:
--   
--   <pre>
--   SufZ                    :: Suffix '[1,2,3] '[1,2,3]
--   SufS SufZ               :: Suffix   '[2,3] '[1,2,3]
--   SufS (SufS SufZ)        :: Suffix     '[3] '[1,2,3]
--   SufS (SufS (SufS SufZ)) :: Suffix      '[] '[1,2,3]
--   </pre>
--   
--   Rule of thumb for construction: the number of <a>SufS</a> is the
--   number of items to "drop" before getting the suffix.
--   
--   This is essentially the second half of an <a>Append</a>, but is
--   conceptually easier to work with.
data Suffix :: [k] -> [k] -> Type
[SufZ] :: Suffix as as
[SufS] :: Suffix as bs -> Suffix as (b : bs)

-- | Drop items from a <a>Rec</a> corresponding to a given <a>Suffix</a>.
dropRec :: Suffix as bs -> Rec f bs -> Rec f as

-- | A lens into the suffix of a <a>Rec</a>.
--   
--   Read this type signature as:
--   
--   <pre>
--   <a>suffixLens</a>
--       :: Suffix as bs
--       -&gt; Lens' (Rec f bs) (Rec f as)
--   </pre>
suffixLens :: forall as bs g f. Functor f => Suffix as bs -> (Rec g as -> f (Rec g as)) -> Rec g bs -> f (Rec g bs)

-- | Shave off the initial inhabitants of an <a>Index</a>, keeping only
--   indices a part of a given suffix If the index is out of range,
--   <a>Nothing</a> will be returned.
--   
--   This is essentially <a>splitIndex</a>, but taking only <a>Right</a>
--   results.
dropIndex :: Suffix as bs -> Index bs x -> Maybe (Index as x)

-- | An index pointing to a given item in a suffix can be transformed into
--   an index pointing to the same item in the full list. This is the
--   inverse of <a>dropIndex</a>.
shiftIndex :: Suffix as bs -> Index as x -> Index bs x

-- | An <tt><a>Append</a> as bs cs</tt> witnesses that <tt>cs</tt> is the
--   result of appending <tt>as</tt> and <tt>bs</tt>.
--   
--   Some examples:
--   
--   <pre>
--   AppZ                     :: Append '[]  '[1,2]   '[1,2]
--   AppZ                     :: Append '[]  '[1,2,3] '[1,2,3]
--   AppS AppZ                :: Append '[0] '[1,2]   '[0,1,2]
--   </pre>
--   
--   Rule of thumb for construction: the number of <a>AppS</a> is the
--   number of items in the <i>first</i> list.
--   
--   This basically combines <a>Prefix</a> and <a>Suffix</a>.
data Append :: [k] -> [k] -> [k] -> Type
[AppZ] :: Append '[] as as
[AppS] :: Append as bs cs -> Append (a : as) bs (a : cs)

-- | Convert a <a>Prefix</a> to an <a>Append</a>, with an existential
--   <tt>bs</tt>.
prefixToAppend :: Prefix as cs -> (forall bs. Append as bs cs -> r) -> r

-- | Convert a <a>Suffix</a> to an <a>Append</a>, with an existential
--   <tt>as</tt>.
suffixToAppend :: Suffix bs cs -> (forall as. Append as bs cs -> r) -> r

-- | Convert an <a>Append</a> to a <a>Prefix</a>, forgetting the suffix.
appendToPrefix :: Append as bs cs -> Prefix as cs

-- | Convert an <a>Append</a> to a <a>Suffix</a>, forgetting the prefix
appendToSuffix :: Append as bs cs -> Suffix bs cs

-- | Split an <a>Append</a> into a <a>Prefix</a> and <a>Suffix</a>.
--   Basically <a>appendToPrefix</a> and <a>appendToSuffix</a> at the same
--   time.
splitAppend :: Append as bs cs -> (Prefix as cs, Suffix bs cs)

-- | Split a <a>Rec</a> into a prefix and suffix. Basically <a>takeRec</a>
--   and <a>dropRec</a> combined.
splitRec :: Append as bs cs -> Rec f cs -> (Rec f as, Rec f bs)

-- | Append two <a>Rec</a>s together according to an <a>Append</a>.
appendRec :: Append as bs cs -> Rec f as -> Rec f bs -> Rec f cs

-- | Witness an isomorphism between <a>Rec</a> and two parts that compose
--   it.
--   
--   Read this type signature as:
--   
--   <pre>
--   <a>splitRecIso</a>
--       :: Append as  bs  cs
--       -&gt; Iso (Rec f cs)           (Rec f cs)
--              (Rec f as, Rec f bs) (Rec f as, Rec f bs)
--   </pre>
--   
--   This can be used with the combinators from the lens library.
--   
--   The <a>Append</a> tells the point to split the <a>Rec</a> at.
splitRecIso :: (Profunctor p, Functor f) => Append as bs cs -> p (Rec g as, Rec g bs) (f (Rec g as, Rec g bs)) -> p (Rec g cs) (f (Rec g cs))

-- | Split an <a>Index</a> by an <a>Append</a>. If the <a>Index</a> was in
--   the first part of the list, it'll return <a>Left</a>. If it was in the
--   second part, it'll return <a>Right</a>.
--   
--   This is essentially <a>takeIndex</a> and <a>dropIndex</a> at the same
--   time.
splitIndex :: Append as bs cs -> Index cs x -> Either (Index as x) (Index bs x)
instance forall k (as :: [k]) (bs :: [k]). GHC.Show.Show (Data.Type.List.Sublist.Prefix as bs)
instance forall k (as :: [k]) (bs :: [k]). GHC.Show.Show (Data.Type.List.Sublist.Suffix as bs)
instance forall k (as :: [k]) (bs :: [k]) (cs :: [k]). GHC.Show.Show (Data.Type.List.Sublist.Append as bs cs)
