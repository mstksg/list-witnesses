-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/mstksg/list-witnesses#readme</a>
@package list-witnesses
@version 0.1.0.0


-- | Parameterized heterogeneous list.
module Data.Type.List.Prod

-- | This shows up in many places in the Haskell ecosystem: it's vinyl, or
--   a heterogeneous list parameterized by a functor.
--   
--   A value of type
--   
--   <pre>
--   <a>Prod</a> f '[a,b,c]
--   </pre>
--   
--   contains an <tt>f a</tt>, and <tt>f b</tt>, and an <tt>f c</tt>.
--   
--   While this exists in my places, it's reproduced here to to provide a
--   canonical implementation.
data Prod :: (k -> Type) -> [k] -> Type
[Ø] :: Prod f '[]
[:<] :: f a -> Prod f as -> Prod f (a : as)
infixr 5 :<

-- | Alias for <a>Ø</a>
pNil :: Prod f '[]

-- | (Total) head of a <a>Prod</a>.
headProd :: Prod f (a : as) -> f a

-- | (total) tail of a <a>Prod</a>.
tailProd :: Prod f (a : as) -> Prod f as

-- | A type-preserving lens into a value in a <a>Prod</a>, given a
--   <a>Index</a> indicating which value. This lens cannot change the type
--   of the value, unlike "Data.Type.List.Edit.lensProd'.
--   
--   Read this type signature as:
--   
--   <pre>
--   <tt>lensProd</tt>
--       :: <a>Index</a> as x
--       -&gt; Lens' (<a>Prod</a> g as) (g x)
--   </pre>
lensProd' :: forall as x g f. Functor f => Index as x -> (g x -> f (g x)) -> Prod g as -> f (Prod g as)

-- | Retrieve an element in a <a>Prod</a> at a given index.
indexProd :: Index as x -> Prod f as -> f x

-- | A RankN map over items in a <a>Prod</a>.
mapProd :: forall f g as. () => (forall x. f x -> g x) -> Prod f as -> Prod g as

-- | A RankN traversal over items in a <a>Prod</a>.
traverseProd :: forall f g h as. Applicative h => (forall x. f x -> h (g x)) -> Prod f as -> h (Prod g as)

-- | RankN fold over items in a <a>Prod</a>.
foldMapProd :: forall f as m. Monoid m => (forall x. f x -> m) -> Prod f as -> m

-- | Zip together two <a>Prod</a>.
zipProd :: Prod f as -> Prod g as -> Prod (f :*: g) as

-- | Convert a <a>Prod</a> of <a>Sing</a> elements into a <a>Sing</a> of
--   the list of elements.
prodSing :: Prod Sing as -> Sing as

-- | Convert a <a>Sing</a> of a list of elements into a <a>Prod</a> of
--   <a>Sing</a> elements.
singProd :: Sing as -> Prod Sing as

-- | Convert a <a>WitAll</a> into a <a>Prod</a>. This requires providing a
--   singleton witnessing the structure of the list.
allProd :: Sing as -> WitAll [] (TyCon1 f) as -> Prod f as

-- | Convert a <a>Prod</a> into a <a>WitAll</a>.
prodAll :: Prod f as -> WitAll [] (TyCon1 f) as


-- | Witnesses regarding single-item edits of lists.
module Data.Type.List.Edit

-- | An <tt><a>Insert</a> as bs x</tt> is a witness that you can insert
--   <tt>x</tt> into some position in list <tt>as</tt> to produce list
--   <tt>bs</tt>. It is essentially <a>Delete</a> flipped.
--   
--   Some examples:
--   
--   <pre>
--   InsZ                   :: Insert '[1,2,3] '[4,1,2,3] 4
--   InsS InsZ              :: Insert '[1,2,3] '[1,4,2,3] 4
--   InsS (InsS InsZ)       :: Insert '[1,2,3] '[1,2,4,3] 4
--   InsS (InsS (InsS InsZ) :: Insert '[1,2,3] '[1,2,3,4] 4
--   </pre>
--   
--   <tt>bs</tt> will always be exactly one item longer than <tt>as</tt>.
data Insert :: [k] -> [k] -> k -> Type
[InsZ] :: Insert as (x : as) x
[InsS] :: Insert as bs x -> Insert (a : as) (a : bs) x

-- | A <tt><a>Delete</a> as bs x</tt> is a witness that you can delete item
--   <tt>x</tt> from <tt>as</tt> to produce the list <tt>bs</tt>. It is
--   essentially <a>Insert</a> flipped.
--   
--   Some examples:
--   
--   <pre>
--   DelZ             :: Delete '[1,2,3] '[2,3] 1
--   DelS DelZ        :: Delete '[1,2,3] '[2,3] 2
--   DelS (DelS DelZ) :: Delete '[1,2,3] '[1,2] 3
--   </pre>
--   
--   <tt>bs</tt> will always be exactly one item shorter than <tt>as</tt>.
data Delete :: [k] -> [k] -> k -> Type
[DelZ] :: Delete (x : as) as x
[DelS] :: Delete as bs x -> Delete (a : as) (a : bs) x
insToDel :: Insert as bs x -> Delete bs as x

-- | Flip a deletion
delToIns :: Delete as bs x -> Insert bs as x

-- | A <tt><a>Substitute</a> as bs x y</tt> is a witness that you can
--   replace item <tt>x</tt> in <tt>as</tt> with item <tt>y</tt> to produce
--   <tt>bs</tt>.
--   
--   Some examples:
--   
--   <pre>
--   SubZ             :: Substitute '[1,2,3] '[4,2,3] 1 4
--   SubS SubZ        :: Substitute '[1,2,3] '[1,4,3] 2 4
--   SubS (SubS SubZ) :: Substitute '[1,2,3] '[1,2,4] 3 4
--   </pre>
data Substitute :: [k] -> [k] -> k -> k -> Type
[SubZ] :: Substitute (x : as) (y : as) x y
[SubS] :: Substitute as bs x y -> Substitute (c : as) (c : bs) x y

-- | Flip a substitution
flipSub :: Substitute as bs x y -> Substitute bs as y x

-- | Decompose a <a>Substitute</a> into a <a>Delete</a> followed by an
--   <a>Insert</a>.
subToDelIns :: Substitute as bs x y -> (forall cs. Delete as cs x -> Insert cs bs y -> r) -> r

-- | An <tt><a>Edit</a> as bs</tt> is an edit script transforming
--   <tt>as</tt> into <tt>bs</tt> through successive insertions, deletions,
--   and substitutions.
data Edit :: [k] -> [k] -> Type
[ENil] :: Edit as as
[EIns] :: Insert bs cs x -> Edit as bs -> Edit as cs
[EDel] :: Delete bs cs x -> Edit as bs -> Edit as cs
[ESub] :: Substitute bs cs x y -> Edit as bs -> Edit as cs

-- | Compose two <a>Edit</a>s
compEdit :: Edit as bs -> Edit bs cs -> Edit as cs

-- | Reverse an <a>Edit</a> script. O(n^2).
flipEdit :: Edit as bs -> Edit bs as

-- | Insert a value into a <a>Prod</a>, at a position indicated by the
--   <a>Insert</a>.
insertProd :: Insert as bs x -> f x -> Prod f as -> Prod f bs

-- | Delete a value in a <a>Prod</a>, at a position indicated by the
--   <a>Delete</a>.
deleteProd :: Delete as bs x -> Prod f as -> Prod f bs

-- | Retrieve and delete a value in a <a>Prod</a>, at a position indicated
--   by the <a>Delete</a>.
deleteGetProd :: Delete as bs x -> Prod f as -> (f x, Prod f bs)

-- | A type-changing lens into a value in a <a>Prod</a>, given a
--   <a>Substitute</a> indicating which value. This lens can change the
--   type of the value, unlike <a>lensProd'</a>.
--   
--   Read this type signature as:
--   
--   <pre>
--   <a>lensProd</a>
--       :: <a>Substitute</a> as bs x y
--       -&gt; Lens (<a>Prod</a> g as) (Prod g bs) (g x) (g y)
--   </pre>
lensProd :: forall as bs x y g f. Functor f => Substitute as bs x y -> (g x -> f (g y)) -> Prod g as -> f (Prod g bs)

-- | Substitute a value in a <a>Prod</a> at a given position, indicated by
--   the <a>Substitute</a>. This is essentially a specialized version of
--   <a>lensProd</a>.
substituteProd :: Substitute as bs x y -> (f x -> f y) -> Prod f as -> Prod f bs

-- | If you add an item to <tt>as</tt> to create <tt>bs</tt>, you also need
--   to shift an <tt><a>Index</a> as y</tt> to <tt>Index bs y</tt>. This
--   shifts the <a>Index</a> in <tt>as</tt> to become an <a>Index</a> in
--   <tt>bs</tt>, but makes sure that the index points to the same original
--   value.
shiftIndex :: Insert as bs x -> Index as y -> Index bs y

-- | Used as the return type of <a>unshiftIndex</a>. An
--   <tt><a>Unshifted</a> bs x y</tt> is like a <tt><a>Maybe</a>
--   (<a>Index</a> bs y)</tt>, except the <a>Nothing</a> case witnesses
--   that <tt>x ~ y</tt>.
data Unshifted :: [k] -> k -> k -> Type
[GotDeleted] :: Unshifted bs x x
[NotDeleted] :: Index bs y -> Unshifted bs x y

-- | If you delete an item in <tt>as</tt> to create <tt>bs</tt>, you also
--   need to move <tt><a>Index</a> as y</tt> into <tt>Index bs y</tt>. This
--   transforms the <a>Index</a> in <tt>as</tt> to become an <a>Index</a>
--   in <tt>bs</tt>, making sure the index points to the same original
--   value.
--   
--   However, there is a possibility that the deleted item is the item that
--   the index was originally pointing to. If this is the case, this
--   function returns <a>GotDeleted</a>, a witness that <tt>x ~ y</tt>.
--   Otherwise, it returns <a>NotDeleted</a> with the unshifted index.
unshiftIndex :: Delete as bs x -> Index as y -> Unshifted bs x y

-- | A version of <a>unshiftIndex</a> returning a simple <a>Maybe</a>. This
--   can be used if you don't care about witnessing that <tt>x ~ y</tt> in
--   the case that the index is the item that is deleted.
unshiftIndex_ :: Delete as bs x -> Index as y -> Maybe (Index bs y)

-- | Used as the return type of <a>reshiftIndex</a>. An
--   <tt><a>Reshifted</a> bs x y z</tt> is like an <tt><a>Either</a>
--   (<a>Index</a> bs y) (<a>Index</a> bs z)</tt>, except the <a>Left</a>
--   case witnesses that <tt>x ~ z</tt>.
data Reshifted :: [k] -> k -> k -> k -> Type
[GotSubbed] :: Index bs y -> Reshifted bs z y z
[NotSubbed] :: Index bs z -> Reshifted bs x y z

-- | If you substitute an item in <tt>as</tt> to create <tt>bs</tt>, you
--   also need to reshift <tt><a>Index</a> as z</tt> into <tt><a>Index</a>
--   bs z</tt>. This reshifts the <a>Index</a> in <tt>as</tt> to become an
--   <a>Index</a> in <tt>bs</tt>, making sure the index points to the same
--   original value.
--   
--   However, there is a possibility that the substituted item is the item
--   that the index was originally pointing to. If this is the case, this
--   function returns <a>GotSubbed</a>, a witness that <tt>x ~ z</tt>.
--   Otherwise, it returns <a>NotSubbed</a>. Both contain the updated
--   index.
reshiftIndex :: Substitute as bs x y -> Index as z -> Reshifted bs x y z

-- | A version of <a>reshiftIndex</a> returning a simple <a>Either</a>.
--   This can be the case if you don't care about witnessing <tt>x ~ z</tt>
--   in the case that the index is the item that was substituted.
reshiftIndex_ :: Substitute as bs x y -> Index as z -> Either (Index bs y) (Index bs z)
instance forall k (as :: [k]) (bs :: [k]) (x :: k). GHC.Show.Show (Data.Type.List.Edit.Insert as bs x)
instance forall k (as :: [k]) (bs :: [k]) (x :: k). GHC.Show.Show (Data.Type.List.Edit.Delete as bs x)
instance forall k (as :: [k]) (bs :: [k]) (x :: k) (y :: k). GHC.Show.Show (Data.Type.List.Edit.Substitute as bs x y)
instance forall k (as :: [k]) (bs :: [k]). GHC.Show.Show (Data.Type.List.Edit.Edit as bs)
instance forall k (bs :: [k]) (x :: k) (y :: k). GHC.Show.Show (Data.Type.List.Edit.Unshifted bs x y)
instance Control.Category.Category Data.Type.List.Edit.Edit


-- | Witnesses regarding sublists of lists.
module Data.Type.List.Sublist

-- | A <tt><a>Prefix</a> as bs</tt> witnesses that <tt>as</tt> is a prefix
--   of <tt>bs</tt>.
--   
--   Some examples:
--   
--   <pre>
--   PreZ                    :: Prefix '[]      '[1,2,3]
--   PreS PreZ               :: Prefix '[1]     '[1,2,3]
--   PreS (PreS PreZ)        :: Prefix '[1,2]   '[1,2,3]
--   PreS (PreS (PreS PreZ)) :: Prefix '[1,2,3] '[1,2,3]
--   </pre>
--   
--   Rule of thumb for construction: the number of <a>PreS</a> is the
--   number of items in the prefix.
--   
--   This is essentially the first half of an <a>Append</a>, but is
--   conceptually easier to work with.
data Prefix :: [k] -> [k] -> Type
[PreZ] :: Prefix '[] as
[PreS] :: Prefix as bs -> Prefix (a : as) (a : bs)

-- | Take items from a <a>Prod</a> corresponding to a given <a>Prefix</a>.
takeProd :: Prefix as bs -> Prod f bs -> Prod f as

-- | A lens into the prefix of a <a>Prod</a>.
--   
--   Read this type signature as:
--   
--   <pre>
--   <a>prefixLens</a>
--       :: Prefix as bs
--       -&gt; Lens' (Prod f bs) (Prod f as)
--   </pre>
prefixLens :: forall as bs g f. Functor f => Prefix as bs -> (Prod g as -> f (Prod g as)) -> Prod g bs -> f (Prod g bs)

-- | Shave off the final inhabitants of an <a>Index</a>, keeping only
--   indices a part of a given prefix. If the index is out of range,
--   <a>Nothing</a> will be returned.
takeIndex :: Prefix as bs -> Index bs x -> Maybe (Index as x)

-- | A <tt><a>Suffix</a> as bs</tt> witnesses that <tt>as</tt> is a suffix
--   of <tt>bs</tt>.
--   
--   Some examples:
--   
--   <pre>
--   SufZ                      :: Suffix '[1,2,3] '[1,2,3]
--   SufS SufZ                 :: Suffix   '[2,3] '[1,2,3]
--   SufS (SufS SufZ)          :: Suffix     '[3] '[1,2,3]
--   SufS (SufS (SufS (SufZ))) :: Suffix      '[] '[1,2,3]
--   </pre>
--   
--   Rule of thumb for construction: the number of <a>SufS</a> is the
--   number of items to "drop" before getting the suffix.
--   
--   This is essentially the second half of an <a>Append</a>, but is
--   conceptually easier to work with.
data Suffix :: [k] -> [k] -> Type
[SufZ] :: Suffix as as
[SufS] :: Suffix as bs -> Suffix as (b : bs)

-- | Drop items from a <a>Prod</a> corresponding to a given <a>Suffix</a>.
dropProd :: Suffix as bs -> Prod f bs -> Prod f as

-- | A lens into the suffix of a <a>Prod</a>.
--   
--   Read this type signature as:
--   
--   <pre>
--   <a>suffixLens</a>
--       :: Suffix as bs
--       -&gt; Lens' (Prod f bs) (Prod f as)
--   </pre>
suffixLens :: forall as bs g f. Functor f => Suffix as bs -> (Prod g as -> f (Prod g as)) -> Prod g bs -> f (Prod g bs)

-- | Shave off the initial inhabitants of an <a>Index</a>, keeping only
--   indices a part of a given suffix If the index is out of range,
--   <a>Nothing</a> will be returned.
dropIndex :: Suffix as bs -> Index bs x -> Maybe (Index as x)

-- | An <tt><a>Append</a> as bs cs</tt> witnesses that <tt>cs</tt> is the
--   result of appending <tt>as</tt> and <tt>bs</tt>.
--   
--   Some examples:
--   
--   <pre>
--   AppZ                     :: Append '[]  '[1,2]   '[1,2]
--   AppZ                     :: Append '[]  '[1,2,3] '[1,2,3]
--   AppS AppZ                :: Append '[0] '[1,2]   '[0,1,2]
--   </pre>
--   
--   Rule of thumb for construction: the number of <a>AppS</a> is the
--   number of items in the <i>first</i> list.
--   
--   This basically combines <a>Prefix</a> and <a>Suffix</a>.
data Append :: [k] -> [k] -> [k] -> Type
[AppZ] :: Append '[] as as
[AppS] :: Append as bs cs -> Append (a : as) bs (a : cs)

-- | Convert a <a>Prefix</a> to an <a>Append</a>, with an existential
--   <tt>bs</tt>.
prefixToAppend :: Prefix as cs -> (forall bs. Append as bs cs -> r) -> r

-- | Convert a <a>Suffix</a> to an <a>Append</a>, with an existential
--   <tt>as</tt>.
suffixToAppend :: Suffix bs cs -> (forall as. Append as bs cs -> r) -> r

-- | Convert an <a>Append</a> to a <a>Prefix</a>, forgetting the suffix.
appendToPrefix :: Append as bs cs -> Prefix as cs

-- | Convert an <a>Append</a> to a <a>Suffix</a>, forgetting the prefix
appendToSuffix :: Append as bs cs -> Suffix bs cs

-- | Split an <a>Append</a> into a <a>Prefix</a> and <a>Suffix</a>.
--   Basically <a>appendToPrefix</a> and <a>appendToSuffix</a> at the same
--   time.
splitAppend :: Append as bs cs -> (Prefix as cs, Suffix bs cs)

-- | Split a <a>Prod</a> into a prefix and suffix. Basically
--   <a>takeProd</a> and <a>dropProd</a> combined.
splitProd :: Append as bs cs -> Prod f cs -> (Prod f as, Prod f bs)

-- | Append two <a>Prod</a>s together according to an <a>Append</a>.
appendProd :: Append as bs cs -> Prod f as -> Prod f bs -> Prod f cs

-- | Witness an isomorphism between <a>Prod</a> and two parts that compose
--   it.
--   
--   Read this type signature as:
--   
--   <pre>
--   <a>splitProdIso</a>
--       :: Append as  bs  cs
--       -&gt; Iso (Prod f cs)            (Prod f cs)
--              (Prod f as, Prod f bs) (Prod f as, Prod f bs)
--   </pre>
--   
--   This can be used with the combinators from the lens library.
--   
--   The <a>Append</a> tells the point to split the <a>Prod</a> at.
splitProdIso :: (Profunctor p, Functor f) => Append as bs cs -> p (Prod g as, Prod g bs) (f (Prod g as, Prod g bs)) -> p (Prod g cs) (f (Prod g cs))

-- | Split an <a>Index</a> by an <a>Append</a>. If the <a>Index</a> was in
--   the first part of the list, it'll return <a>Left</a>. If it was int he
--   second part, it'll return <a>Right</a>.
splitIndex :: Append as bs cs -> Index cs x -> Either (Index as x) (Index bs x)
instance forall k (as :: [k]) (bs :: [k]). GHC.Show.Show (Data.Type.List.Sublist.Prefix as bs)
instance forall k (as :: [k]) (bs :: [k]). GHC.Show.Show (Data.Type.List.Sublist.Suffix as bs)
instance forall k (as :: [k]) (bs :: [k]) (cs :: [k]). GHC.Show.Show (Data.Type.List.Sublist.Append as bs cs)
