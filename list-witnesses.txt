-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Witnesses for working with type-level lists
--   
--   Collection of assorted inductive witnesses and functions for working
--   with type-level lists.
--   
--   <ul>
--   <li>*Data.Type.List.Edit* contains single-item edits of lists,
--   including insertion, deletion, and substitution.</li>
--   <li>*Data.Type.List.Sublist* contains witnesses for prefixes,
--   suffixes, and two-way splits of type-level lists.</li>
--   </ul>
@package list-witnesses
@version 0.1.3.1


-- | Witnesses regarding single-item edits of lists.
module Data.Type.List.Edit

-- | An <tt><a>Insert</a> as bs x</tt> is a witness that you can insert
--   <tt>x</tt> into some position in list <tt>as</tt> to produce list
--   <tt>bs</tt>. It is essentially <a>Delete</a> flipped.
--   
--   Some examples:
--   
--   <pre>
--   InsZ                   :: Insert '[1,2,3] '[4,1,2,3] 4
--   InsS InsZ              :: Insert '[1,2,3] '[1,4,2,3] 4
--   InsS (InsS InsZ)       :: Insert '[1,2,3] '[1,2,4,3] 4
--   InsS (InsS (InsS InsZ) :: Insert '[1,2,3] '[1,2,3,4] 4
--   </pre>
--   
--   <tt>bs</tt> will always be exactly one item longer than <tt>as</tt>.
data Insert :: [k] -> [k] -> k -> Type
[InsZ] :: Insert as (x : as) x
[InsS] :: Insert as bs x -> Insert (a : as) (a : bs) x

-- | Automatically generate an <a>Insert</a> if <tt>as</tt>, <tt>bs</tt>
--   and <tt>x</tt> are known statically.
autoInsert :: forall as bs x. Auto (IsInsert as bs) x => Insert as bs x

-- | A <tt><a>Delete</a> as bs x</tt> is a witness that you can delete item
--   <tt>x</tt> from <tt>as</tt> to produce the list <tt>bs</tt>. It is
--   essentially <a>Insert</a> flipped.
--   
--   Some examples:
--   
--   <pre>
--   DelZ             :: Delete '[1,2,3] '[2,3] 1
--   DelS DelZ        :: Delete '[1,2,3] '[2,3] 2
--   DelS (DelS DelZ) :: Delete '[1,2,3] '[1,2] 3
--   </pre>
--   
--   <tt>bs</tt> will always be exactly one item shorter than <tt>as</tt>.
data Delete :: [k] -> [k] -> k -> Type
[DelZ] :: Delete (x : as) as x
[DelS] :: Delete as bs x -> Delete (a : as) (a : bs) x

-- | Automatically generate an <a>Delete</a> if <tt>as</tt>, <tt>bs</tt>
--   and <tt>x</tt> are known statically.
autoDelete :: forall as bs x. Auto (IsDelete as bs) x => Delete as bs x

-- | Flip an insertion.
insToDel :: Insert as bs x -> Delete bs as x

-- | Flip a deletion.
delToIns :: Delete as bs x -> Insert bs as x

-- | A <tt><a>Substitute</a> as bs x y</tt> is a witness that you can
--   replace item <tt>x</tt> in <tt>as</tt> with item <tt>y</tt> to produce
--   <tt>bs</tt>.
--   
--   Some examples:
--   
--   <pre>
--   SubZ             :: Substitute '[1,2,3] '[4,2,3] 1 4
--   SubS SubZ        :: Substitute '[1,2,3] '[1,4,3] 2 4
--   SubS (SubS SubZ) :: Substitute '[1,2,3] '[1,2,4] 3 4
--   </pre>
data Substitute :: [k] -> [k] -> k -> k -> Type
[SubZ] :: Substitute (x : as) (y : as) x y
[SubS] :: Substitute as bs x y -> Substitute (c : as) (c : bs) x y

-- | Automatically generate an <a>Substitute</a> if <tt>as</tt>,
--   <tt>bs</tt>, <tt>x</tt>, and <tt>y</tt> are known statically.
autoSubstitute :: forall as bs x y. Auto (IsSubstitute as bs x) y => Substitute as bs x y

-- | Flip a substitution
flipSub :: Substitute as bs x y -> Substitute bs as y x

-- | Decompose a <a>Substitute</a> into a <a>Delete</a> followed by an
--   <a>Insert</a>.
subToDelIns :: Substitute as bs x y -> (forall cs. Delete as cs x -> Insert cs bs y -> r) -> r

-- | A type-level predicate that a given value can be used as an insertion
--   to change <tt>as</tt> to <tt>bs</tt>.
type IsInsert as bs = TyPred (Insert as bs)

-- | If <tt>bs</tt> satisfies <tt><a>InsertedInto</a> as</tt>, it means
--   that there exists some element <tt>x</tt> such that
--   <tt><a>IsInsert</a> as bs @@ x</tt>: you can get <tt>bs</tt> by
--   inserting <tt>x</tt> into <tt>as</tt> somewhere.
--   
--   In other words, <tt><a>InsertedInto</a> as</tt> is satisfied by
--   <tt>bs</tt> if you can turn <tt>as</tt> into <tt>bs</tt> by inserting
--   one individual item.
--   
--   You can find this element (if it exists) using <a>search</a>, or the
--   <a>Decidable</a> instance of <tt><a>Found</a> (<a>InsertedInto</a>
--   as)</tt>:
--   
--   <pre>
--   <a>searchTC</a> :: SingI as =&gt; Sing bs -&gt; <a>Decision</a> (<a>Σ</a> k (<a>IsInsert</a> as bs))
--   </pre>
--   
--   This will find you the single element you need to insert into
--   <tt>as</tt> to get <tt>bs</tt>, if it exists.
type InsertedInto (as :: [k]) = (TyPP (Insert as) :: ParamPred [k] k)

-- | A type-level predicate that a given value can be used as a deletion to
--   change <tt>as</tt> to <tt>bs</tt>.
type IsDelete as bs = TyPred (Delete as bs)

-- | If <tt>bs</tt> satisfies <tt><a>DeletedFrom</a> as</tt>, it means that
--   there exists some element <tt>x</tt> such that <tt><a>IsDelete</a> as
--   bs @@ x</tt>: you can get <tt>bs</tt> by deleting <tt>x</tt> from
--   <tt>as</tt> somewhere.
--   
--   In other words, <tt><a>DeletedFrom</a> as</tt> is satisfied by
--   <tt>bs</tt> if you can turn <tt>as</tt> into <tt>bs</tt> by deleting
--   one individual item.
--   
--   You can find this element (if it exists) using <a>search</a>, or the
--   <a>Decidable</a> instance of <tt><a>Found</a> (<a>DeletedFrom</a>
--   as)</tt>.
--   
--   <pre>
--   <a>searchTC</a> :: SingI as =&gt; Sing bs -&gt; <a>Decision</a> (<a>Σ</a> k (<a>IsDelete</a> as bs))
--   </pre>
--   
--   This will find you the single element you need to delete from
--   <tt>as</tt> to get <tt>bs</tt>, if it exists.
type DeletedFrom (as :: [k]) = (TyPP (Delete as) :: ParamPred [k] k)

-- | A type-level predicate that a given value can be used as a
--   substitution of <tt>x</tt> to change <tt>as</tt> to <tt>bs</tt>.
type IsSubstitute as bs x = TyPred (Substitute as bs x)

-- | Kind-indexed singleton for <a>Insert</a>.
data SInsert as bs x :: Insert as bs x -> Type
[SInsZ] :: SInsert as (x : as) x  'InsZ
[SInsS] :: SInsert as bs x ins -> SInsert (a : as) (a : bs) x ( 'InsS ins)

-- | Kind-indexed singleton for <a>Delete</a>.
data SDelete as bs x :: Delete as bs x -> Type
[SDelZ] :: SDelete (x : as) as x  'DelZ
[SDelS] :: SDelete as bs x del -> SDelete (a : as) (a : bs) x ( 'DelS del)

-- | Kind-indexed singleton for <a>Substitute</a>.
data SSubstitute as bs x y :: Substitute as bs x y -> Type
[SSubZ] :: SSubstitute (x : as) (y : as) x y  'SubZ
[SSubS] :: SSubstitute as bs x y sub -> SSubstitute (c : as) (c : bs) x y ( 'SubS sub)

-- | An <tt><a>Edit</a> as bs</tt> is a reversible edit script transforming
--   <tt>as</tt> into <tt>bs</tt> through successive insertions, deletions,
--   and substitutions.
--   
--   TODO: implement Wagner-Fischer to minimize find a minimal edit
--   distance
data Edit :: [k] -> [k] -> Type
[ENil] :: Edit as as
[EIns] :: Insert bs cs x -> Edit as bs -> Edit as cs
[EDel] :: Delete bs cs x -> Edit as bs -> Edit as cs
[ESub] :: Substitute bs cs x y -> Edit as bs -> Edit as cs

-- | Compose two <a>Edit</a>s
compEdit :: Edit as bs -> Edit bs cs -> Edit as cs

-- | Reverse an <a>Edit</a> script. O(n^2). Please do not use ever in any
--   circumstance.
--   
--   TODO: Make O(n) using diff lists.
flipEdit :: Edit as bs -> Edit bs as

-- | Insert a value into a <a>Rec</a>, at a position indicated by the
--   <a>Insert</a>.
insertRec :: Insert as bs x -> f x -> Rec f as -> Rec f bs

-- | Delete a value in a <a>Rec</a>, at a position indicated by the
--   <a>Delete</a>.
deleteRec :: Delete as bs x -> Rec f as -> Rec f bs

-- | Retrieve and delete a value in a <a>Rec</a>, at a position indicated
--   by the <a>Delete</a>.
deleteGetRec :: Delete as bs x -> Rec f as -> (f x, Rec f bs)

-- | A type-changing lens into a value in a <a>Rec</a>, given a
--   <a>Substitute</a> indicating which value.
--   
--   For example:
--   
--   <pre>
--   recLens (SubS SubZ)
--        :: Lens (Rec f '[a,b,c,d]) (Rec f '[a,e,c,d])
--                (f b)              (f e)
--   </pre>
--   
--   The number of <a>SubS</a> in the index essentially indicates the index
--   to edit at.
--   
--   This is similar to <a>rlensC</a> from <i>vinyl</i>, but is built
--   explicitly and inductively, instead of using typeclass magic.
recLens :: forall as bs x y f. () => Substitute as bs x y -> Lens (Rec f as) (Rec f bs) (f x) (f y)

-- | Substitute a value in a <a>Rec</a> at a given position, indicated by
--   the <a>Substitute</a>. This is essentially a specialized version of
--   <a>recLens</a>.
substituteRec :: Substitute as bs x y -> (f x -> f y) -> Rec f as -> Rec f bs

-- | If you add an item to <tt>as</tt> to create <tt>bs</tt>, you also need
--   to shift an <tt><a>Index</a> as y</tt> to <tt>Index bs y</tt>. This
--   shifts the <a>Index</a> in <tt>as</tt> to become an <a>Index</a> in
--   <tt>bs</tt>, but makes sure that the index points to the same original
--   value.
insertIndex :: Insert as bs x -> Index as y -> Index bs y

-- | Used as the return type of <a>deleteIndex</a>. An <tt><a>DeletedIx</a>
--   bs x y</tt> is like a <tt><a>Maybe</a> (<a>Index</a> bs y)</tt>,
--   except the <a>Nothing</a> case witnesses that <tt>x ~ y</tt>.
data DeletedIx :: [k] -> k -> k -> Type
[GotDeleted] :: DeletedIx bs x x
[NotDeleted] :: Index bs y -> DeletedIx bs x y

-- | If you delete an item in <tt>as</tt> to create <tt>bs</tt>, you also
--   need to move <tt><a>Index</a> as y</tt> into <tt>Index bs y</tt>. This
--   transforms the <a>Index</a> in <tt>as</tt> to become an <a>Index</a>
--   in <tt>bs</tt>, making sure the index points to the same original
--   value.
--   
--   However, there is a possibility that the deleted item is the item that
--   the index was originally pointing to. If this is the case, this
--   function returns <a>GotDeleted</a>, a witness that <tt>x ~ y</tt>.
--   Otherwise, it returns <a>NotDeleted</a> with the unshifted index.
deleteIndex :: Delete as bs x -> Index as y -> DeletedIx bs x y

-- | A version of <a>deleteIndex</a> returning a simple <a>Maybe</a>. This
--   can be used if you don't care about witnessing that <tt>x ~ y</tt> in
--   the case that the index is the item that is deleted.
deleteIndex_ :: Delete as bs x -> Index as y -> Maybe (Index bs y)

-- | Used as the return type of <a>substituteIndex</a>. An
--   <tt><a>SubstitutedIx</a> bs x y z</tt> is like an <tt><a>Either</a>
--   (<a>Index</a> bs y) (<a>Index</a> bs z)</tt>, except the <a>Left</a>
--   case witnesses that <tt>x ~ z</tt>.
data SubstitutedIx :: [k] -> k -> k -> k -> Type
[GotSubbed] :: Index bs y -> SubstitutedIx bs z y z
[NotSubbed] :: Index bs z -> SubstitutedIx bs x y z

-- | If you substitute an item in <tt>as</tt> to create <tt>bs</tt>, you
--   also need to reshift <tt><a>Index</a> as z</tt> into <tt><a>Index</a>
--   bs z</tt>. This reshifts the <a>Index</a> in <tt>as</tt> to become an
--   <a>Index</a> in <tt>bs</tt>, making sure the index points to the same
--   original value.
--   
--   However, there is a possibility that the substituted item is the item
--   that the index was originally pointing to. If this is the case, this
--   function returns <a>GotSubbed</a>, a witness that <tt>x ~ z</tt>.
--   Otherwise, it returns <a>NotSubbed</a>. Both contain the updated
--   index.
substituteIndex :: Substitute as bs x y -> Index as z -> SubstitutedIx bs x y z

-- | A version of <a>substituteIndex</a> returning a simple <a>Either</a>.
--   This can be the case if you don't care about witnessing <tt>x ~ z</tt>
--   in the case that the index is the item that was substituted.
substituteIndex_ :: Substitute as bs x y -> Index as z -> Either (Index bs y) (Index bs z)

-- | Given an <a>Index</a> pointing to an element, create a <a>Delete</a>
--   corresponding to the given item. The type of the resulting list is
--   existentially quantified, is guaranteed to be just exactly the
--   original list minus the specified element.
withDelete :: Index as x -> (forall bs. Delete as bs x -> r) -> r

-- | Given an <a>Index</a> pointing to an element, create an <a>Insert</a>
--   placing an item <i>directly before</i> the given element. The type is
--   existentailly quantified.
withInsert :: Index as x -> (forall bs. Insert as bs y -> r) -> r

-- | Given an <a>Index</a> pointing to an element, create an <a>Insert</a>
--   placing an item <i>directly after</i> the given element. The type is
--   existentailly quantified.
withInsertAfter :: Index as x -> (forall bs. Insert as bs y -> r) -> r

-- | Type-level version of <a>insertIndex</a>. Because of how GADTs and
--   type families interact, the type-level lists and kinds of the
--   insertion and index must be provided.
type family InsertIndex as bs x y (ins :: Insert as bs x) (i :: Index as y) :: Index bs y

-- | Singleton witness for <a>InsertIndex</a>.
sInsertIndex :: SInsert as bs x ins -> SIndex as y i -> SIndex bs y (InsertIndex as bs x y ins i)

-- | Kind-indexed singleton for <a>DeletedIx</a>.
data SDeletedIx bs x y :: DeletedIx bs x y -> Type
[SGotDeleted] :: SDeletedIx bs x x  'GotDeleted
[SNotDeleted] :: SIndex bs y i -> SDeletedIx bs x y ( 'NotDeleted i)

-- | Type-level version of <a>deleteIndex</a>. Because of how GADTs and
--   type families interact, the type-level lists and kinds of the
--   insertion and index must be provided.
type family DeleteIndex as bs x y (del :: Delete as bs x) (i :: Index as y) :: DeletedIx bs x y

-- | Singleton witness for <a>DeleteIndex</a>.
sDeleteIndex :: SDelete as bs x del -> SIndex as y i -> SDeletedIx bs x y (DeleteIndex as bs x y del i)

-- | Kind-indexed singleton for <a>SubstitutedIx</a>.
data SSubstitutedIx bs x y z :: SubstitutedIx bs x y z -> Type
[SGotSubbed] :: SIndex bs y i -> SSubstitutedIx bs z y z ( 'GotSubbed i)
[SNotSubbed] :: SIndex bs z i -> SSubstitutedIx bs x y z ( 'NotSubbed i)

-- | Type-level version of <a>substituteIndex</a>. Because of how GADTs and
--   type families interact, the type-level lists and kinds of the
--   insertion and index must be provided.
type family SubstituteIndex as bs x y z (s :: Substitute as bs x y) (i :: Index as z) :: SubstitutedIx bs x y z

-- | Singleton witness for <a>SubstituteIndex</a>.
sSubstituteIndex :: SSubstitute as bs x y s -> SIndex as z i -> SSubstitutedIx bs x y z (SubstituteIndex as bs x y z s i)

-- | Defunctionalization symbol for <a>InsertIndex</a>, expecting only the
--   kind variables.
data InsertIndexSym0 as bs x y :: Insert as bs x ~> Index as y ~> Index bs y

-- | Defunctionalization symbol for <a>InsertIndex</a>, expecting the
--   <a>Insert</a> along with the kind variables.
data InsertIndexSym as bs x y :: Insert as bs x -> Index as y ~> Index bs y

-- | Defunctionalization symbol for <a>DeleteIndex</a>, expecting only the
--   kind variables.
data DeleteIndexSym0 as bs x y :: Delete as bs x ~> Index as y ~> DeletedIx bs x y

-- | Defunctionalization symbol for <a>DeleteIndex</a>, expecting the
--   <a>Delete</a> along with the kind variables.
data DeleteIndexSym as bs x y :: Delete as bs x -> Index as y ~> DeletedIx bs x y

-- | Defunctionalization symbol for <a>SubstituteIndex</a>, expecting only
--   the kind variables.
data SubstituteIndexSym0 as bs x y z :: Substitute as bs x y ~> Index as z ~> SubstitutedIx bs x y z

-- | Defunctionalization symbol for <a>SubstituteIndex</a>, expecting the
--   <a>Substitute</a> along with the kind variables.
data SubstituteIndexSym as bs x y z :: Substitute as bs x y -> Index as z ~> SubstitutedIx bs x y z
instance forall k (as :: [k]) (bs :: [k]) (x :: k). GHC.Show.Show (Data.Type.List.Edit.Insert as bs x)
instance forall a (as :: [a]) (bs :: [a]) (x :: a) (del :: Data.Type.List.Edit.Insert as bs x). GHC.Show.Show (Data.Type.List.Edit.SInsert as bs x del)
instance forall k (as :: [k]) (bs :: [k]) (x :: k). GHC.Show.Show (Data.Type.List.Edit.Delete as bs x)
instance forall a (as :: [a]) (bs :: [a]) (x :: a) (del :: Data.Type.List.Edit.Delete as bs x). GHC.Show.Show (Data.Type.List.Edit.SDelete as bs x del)
instance forall k (as :: [k]) (bs :: [k]) (x :: k) (y :: k). GHC.Show.Show (Data.Type.List.Edit.Substitute as bs x y)
instance forall k (as :: [k]) (bs :: [k]). GHC.Show.Show (Data.Type.List.Edit.Edit as bs)
instance forall k (bs :: [k]) (x :: k) (y :: k). GHC.Show.Show (Data.Type.List.Edit.DeletedIx bs x y)
instance Control.Category.Category Data.Type.List.Edit.Edit
instance forall k (x :: k) (as :: [k]) (y :: k). Data.Type.Predicate.Auto.Auto (Data.Type.List.Edit.IsSubstitute (x : as) (y : as) x) y
instance forall k (as :: [k]) (bs :: [k]) (x :: k) (y :: k) (c :: k). Data.Type.Predicate.Auto.Auto (Data.Type.List.Edit.IsSubstitute as bs x) y => Data.Type.Predicate.Auto.Auto (Data.Type.List.Edit.IsSubstitute (c : as) (c : bs) x) y
instance forall k (as :: [k]). (Data.Singletons.Decide.SDecide k, Data.Singletons.Internal.SingI as) => Data.Type.Predicate.Decidable (Data.Type.Predicate.Param.Found (Data.Type.List.Edit.DeletedFrom as))
instance forall k (x :: k) (as :: [k]). Data.Type.Predicate.Auto.Auto (Data.Type.List.Edit.IsDelete (x : as) as) x
instance forall k (as :: [k]) (bs :: [k]) (x :: k) (a :: k). Data.Type.Predicate.Auto.Auto (Data.Type.List.Edit.IsDelete as bs) x => Data.Type.Predicate.Auto.Auto (Data.Type.List.Edit.IsDelete (a : as) (a : bs)) x
instance forall k (as :: [k]) (bs :: [k]). (Data.Singletons.Decide.SDecide k, Data.Singletons.Internal.SingI as, Data.Singletons.Internal.SingI bs) => Data.Type.Predicate.Decidable (Data.Type.List.Edit.IsDelete as bs)
instance forall k (as :: [k]). (Data.Singletons.Decide.SDecide k, Data.Singletons.Internal.SingI as) => Data.Type.Predicate.Decidable (Data.Type.Predicate.Param.Found (Data.Type.List.Edit.InsertedInto as))
instance forall k (as :: [k]) (x :: k). Data.Type.Predicate.Auto.Auto (Data.Type.List.Edit.IsInsert as (x : as)) x
instance forall k (as :: [k]) (bs :: [k]) (x :: k) (a :: k). Data.Type.Predicate.Auto.Auto (Data.Type.List.Edit.IsInsert as bs) x => Data.Type.Predicate.Auto.Auto (Data.Type.List.Edit.IsInsert (a : as) (a : bs)) x
instance forall k (as :: [k]) (bs :: [k]). (Data.Singletons.Decide.SDecide k, Data.Singletons.Internal.SingI as, Data.Singletons.Internal.SingI bs) => Data.Type.Predicate.Decidable (Data.Type.List.Edit.IsInsert as bs)


-- | Witnesses regarding sublists of lists.
module Data.Type.List.Sublist

-- | A <tt><a>Prefix</a> as bs</tt> witnesses that <tt>as</tt> is a prefix
--   of <tt>bs</tt>.
--   
--   Some examples:
--   
--   <pre>
--   PreZ                    :: Prefix '[]      '[1,2,3]
--   PreS PreZ               :: Prefix '[1]     '[1,2,3]
--   PreS (PreS PreZ)        :: Prefix '[1,2]   '[1,2,3]
--   PreS (PreS (PreS PreZ)) :: Prefix '[1,2,3] '[1,2,3]
--   </pre>
--   
--   Rule of thumb for construction: the number of <a>PreS</a> is the
--   number of items in the prefix.
--   
--   This is essentially the first half of an <a>Append</a>, but is
--   conceptually easier to work with.
data Prefix :: [k] -> [k] -> Type
[PreZ] :: Prefix '[] as
[PreS] :: Prefix as bs -> Prefix (a : as) (a : bs)

-- | A type-level predicate that a given list has <tt>as</tt> as a prefix.
type IsPrefix as = TyPred (Prefix as)

-- | Automatically generate a <a>Prefix</a> if <tt>as</tt> and <tt>bs</tt>
--   are known statically.
autoPrefix :: forall as bs. Auto (IsPrefix as) bs => Prefix as bs

-- | Take items from a <a>Rec</a> corresponding to a given <a>Prefix</a>.
takeRec :: Prefix as bs -> Rec f bs -> Rec f as

-- | A lens into the prefix of a <a>Rec</a>.
prefixLens :: Prefix as bs -> Lens' (Rec f bs) (Rec f as)

-- | Shave off the final inhabitants of an <a>Index</a>, keeping only
--   indices a part of a given prefix. If the index is out of range,
--   <a>Nothing</a> will be returned.
--   
--   This is essentially <a>splitIndex</a>, but taking only <a>Left</a>
--   results.
takeIndex :: Prefix as bs -> Index bs x -> Maybe (Index as x)

-- | An index pointing to a given item in a prefix is also an index
--   pointing to the same item in the full list. This "weakens" the bounds
--   of an index, widening the list at the end but preserving the original
--   index. This is the inverse of <a>takeIndex</a>.
weakenIndex :: Prefix as bs -> Index as x -> Index bs x

-- | Get the <a>Shape</a> associated with a <a>Prefix</a>.
prefixShape :: Prefix as bs -> Shape [] as

-- | A <tt><a>Suffix</a> as bs</tt> witnesses that <tt>as</tt> is a suffix
--   of <tt>bs</tt>.
--   
--   Some examples:
--   
--   <pre>
--   SufZ                    :: Suffix '[1,2,3] '[1,2,3]
--   SufS SufZ               :: Suffix   '[2,3] '[1,2,3]
--   SufS (SufS SufZ)        :: Suffix     '[3] '[1,2,3]
--   SufS (SufS (SufS SufZ)) :: Suffix      '[] '[1,2,3]
--   </pre>
--   
--   Rule of thumb for construction: the number of <a>SufS</a> is the
--   number of items to "drop" before getting the suffix.
--   
--   This is essentially the second half of an <a>Append</a>, but is
--   conceptually easier to work with.
data Suffix :: [k] -> [k] -> Type
[SufZ] :: Suffix as as
[SufS] :: Suffix as bs -> Suffix as (b : bs)

-- | A type-level predicate that a given list has <tt>as</tt> as a suffix.
type IsSuffix as = TyPred (Suffix as)

-- | Automatically generate a <a>Suffix</a> if <tt>as</tt> and <tt>bs</tt>
--   are known statically.
autoSuffix :: forall as bs. Auto (IsSuffix as) bs => Suffix as bs

-- | Drop items from a <a>Rec</a> corresponding to a given <a>Suffix</a>.
dropRec :: Suffix as bs -> Rec f bs -> Rec f as

-- | A lens into the suffix of a <a>Rec</a>.
suffixLens :: Suffix as bs -> Lens' (Rec f bs) (Rec f as)

-- | Shave off the initial inhabitants of an <a>Index</a>, keeping only
--   indices a part of a given suffix If the index is out of range,
--   <a>Nothing</a> will be returned.
--   
--   This is essentially <a>splitIndex</a>, but taking only <a>Right</a>
--   results.
dropIndex :: Suffix as bs -> Index bs x -> Maybe (Index as x)

-- | An index pointing to a given item in a suffix can be transformed into
--   an index pointing to the same item in the full list. This is the
--   inverse of <a>dropIndex</a>.
shiftIndex :: Suffix as bs -> Index as x -> Index bs x

-- | An <tt><a>Append</a> as bs cs</tt> witnesses that <tt>cs</tt> is the
--   result of appending <tt>as</tt> and <tt>bs</tt>.
--   
--   Some examples:
--   
--   <pre>
--   AppZ                     :: Append '[]  '[1,2]   '[1,2]
--   AppZ                     :: Append '[]  '[1,2,3] '[1,2,3]
--   AppS AppZ                :: Append '[0] '[1,2]   '[0,1,2]
--   </pre>
--   
--   Rule of thumb for construction: the number of <a>AppS</a> is the
--   number of items in the <i>first</i> list.
--   
--   This basically combines <a>Prefix</a> and <a>Suffix</a>.
data Append :: [k] -> [k] -> [k] -> Type
[AppZ] :: Append '[] as as
[AppS] :: Append as bs cs -> Append (a : as) bs (a : cs)

-- | A type-level predicate that a given list is the result of appending of
--   <tt>as</tt> and <tt>bs</tt>.
type IsAppend as bs = TyPred (Append as bs)

-- | Automatically generate an <a>Append</a> if <tt>as</tt>, <tt>bs</tt>
--   and <tt>cs</tt> are known statically.
autoAppend :: forall as bs cs. Auto (IsAppend as bs) cs => Append as bs cs

-- | Given <tt>as</tt> and <tt>bs</tt>, create an <tt><a>Append</a> as bs
--   cs</tt> with, with <tt>cs</tt> existentially quantified
withAppend :: Rec f as -> Rec f bs -> (forall cs. Rec f cs -> Append as bs cs -> r) -> r

-- | Convert a <a>Prefix</a> to an <a>Append</a>, with an existential
--   <tt>bs</tt>.
prefixToAppend :: Prefix as cs -> (forall bs. Append as bs cs -> r) -> r

-- | Convert a <a>Suffix</a> to an <a>Append</a>, with an existential
--   <tt>as</tt>.
suffixToAppend :: Suffix bs cs -> (forall as. Append as bs cs -> r) -> r

-- | Convert an <a>Append</a> to a <a>Prefix</a>, forgetting the suffix.
appendToPrefix :: Append as bs cs -> Prefix as cs

-- | Convert an <a>Append</a> to a <a>Suffix</a>, forgetting the prefix
appendToSuffix :: Append as bs cs -> Suffix bs cs

-- | Split an <a>Append</a> into a <a>Prefix</a> and <a>Suffix</a>.
--   Basically <a>appendToPrefix</a> and <a>appendToSuffix</a> at the same
--   time.
splitAppend :: Append as bs cs -> (Prefix as cs, Suffix bs cs)

-- | Get the <a>Shape</a> associated with an <tt>Append'</tt>s prefix.
appendShape :: Append as bs cs -> Shape [] as

-- | Split a <a>Rec</a> into a prefix and suffix. Basically <a>takeRec</a>
--   and <a>dropRec</a> combined.
splitRec :: Append as bs cs -> Rec f cs -> (Rec f as, Rec f bs)

-- | Append two <a>Rec</a>s together according to an <a>Append</a>.
appendRec :: Append as bs cs -> Rec f as -> Rec f bs -> Rec f cs

-- | Witness an isomorphism between <a>Rec</a> and two parts that compose
--   it.
--   
--   Read this type signature as:
--   
--   <pre>
--   <a>splitRecIso</a>
--       :: Append as  bs  cs
--       -&gt; Iso' (Rec f cs) (Rec f as, Rec f bs)
--   </pre>
--   
--   This can be used with the combinators from the lens library.
--   
--   The <a>Append</a> tells the point to split the <a>Rec</a> at.
splitRecIso :: (Profunctor p, Functor f) => Append as bs cs -> p (Rec g as, Rec g bs) (f (Rec g as, Rec g bs)) -> p (Rec g cs) (f (Rec g cs))

-- | Split an <a>Index</a> by an <a>Append</a>. If the <a>Index</a> was in
--   the first part of the list, it'll return <a>Left</a>. If it was in the
--   second part, it'll return <a>Right</a>.
--   
--   This is essentially <a>takeIndex</a> and <a>dropIndex</a> at the same
--   time.
splitIndex :: Append as bs cs -> Index cs x -> Either (Index as x) (Index bs x)

-- | A useful pattern synonym for using <a>Append</a> with <tt>++</tt> from
--   <a>Data.Singletons.Prelude.List</a>.
--   
--   As a <i>pattern</i>, this brings <tt>(as ++ bs) ~ cs</tt> into the
--   context whenever you use it to match on an <tt><a>Append</a> as bs
--   cs</tt>.
--   
--   As an <i>expression</i>, this constructs an <tt><a>Append</a> as bs
--   cs</tt> as long as you have <tt>(as ++ bs) ~ cs</tt> in the context.
pattern AppendWit :: forall as bs cs. (RecApplicative as, RecApplicative bs) => (as ++ bs) ~ cs => Append as bs cs

-- | Witness that <tt><a>Append</a> as bs cs</tt> implies <tt>(as ++ bs) ~
--   cs</tt>, using <tt>++</tt> from <a>Data.Singletons.Prelude.List</a>.
appendWit :: Append as bs cs -> (as ++ bs) :~: cs

-- | <a>appendWit</a> stated as a <a>Predicate</a> implication.
implyAppend :: IsAppend as bs --> EqualTo (as ++ bs)

-- | The inverse of <a>appendWit</a>: if we know <tt>(as ++ bs) ~ cs</tt>
--   (using <tt>++</tt> from <a>Data.Singletons.Prelude.List</a>), we can
--   create an <tt><a>Append</a> as bs cs</tt> given structure witnesses
--   <a>Sing</a>.
unAppendWit :: (as ++ bs) ~ cs => Rec f as -> Rec f bs -> Append as bs cs

-- | A useful pattern synonym for using <a>Append</a> with <tt>++</tt> from
--   <a>Data.Vinyl.TypeLevel</a>.
--   
--   As a <i>pattern</i>, this brings <tt>(as ++ bs) ~ cs</tt> into the
--   context whenever you use it to match on an <tt><a>Append</a> as bs
--   cs</tt>.
--   
--   As an <i>expression</i>, this constructs an <tt><a>Append</a> as bs
--   cs</tt> as long as you have <tt>(as ++ bs) ~ cs</tt> in the context.
pattern AppendWitV :: forall as bs cs. (RecApplicative as, RecApplicative bs) => (as ++ bs) ~ cs => Append as bs cs

-- | Witness that <tt><a>Append</a> as bs cs</tt> implies <tt>(as ++ bs) ~
--   cs</tt>, using <tt>++</tt> from <a>Data.Vinyl.TypeLevel</a>.
appendWitV :: Append as bs cs -> (as ++ bs) :~: cs

-- | <a>appendWitV</a> stated as a <a>Predicate</a> implication.
implyAppendV :: IsAppend as bs --> EqualTo (as ++ bs)

-- | The inverse of <a>appendWitV</a>: if we know <tt>(as ++ bs) ~ cs</tt>
--   (using <tt>++</tt> from <a>Data.Vinyl.TypeLevel</a>), we can create an
--   <tt><a>Append</a> as bs cs</tt> given structure witnesses <a>Sing</a>.
unAppendWitV :: (as ++ bs) ~ cs => Rec f as -> Rec f bs -> Append as bs cs

-- | Combine the powers of <a>AppendWit</a> and <a>AppendWitV</a> by
--   matching on an <a>Append</a> to witness <tt>(as ++ bs) ~ cs</tt> for
--   <i>both</i> <tt>++</tt> from <a>Data.Singletons.Prelude.List</a> and
--   <a>Data.Vinyl.TypeLevel</a>. This also witnesses that <tt>(as ++ bs) ~
--   (as ++ bs)</tt> (for the two different <tt>++</tt>s) by transitive
--   property.
pattern AppendWit' :: forall as bs cs. (RecApplicative as, RecApplicative bs) => ((as ++ bs) ~ cs, (as ++ bs) ~ cs) => Append as bs cs

-- | Given a witness <tt><a>Append</a> as bs cs</tt>, prove that
--   singleton's <tt>++</tt> from <a>Data.Singletons.Prelude.List</a> is
--   the same as vinyl's <tt>++</tt> <a>Data.Vinyl.TypeLevel</a>.
convertAppends :: Append as bs cs -> (as ++ bs) :~: (as ++ bs)

-- | A parameterized predicate that you can use with <a>select</a>: With an
--   <tt><a>AppendedTo</a> as</tt>, you can give <tt>bs</tt> and get
--   <tt>cs</tt> in return, where <tt>cs</tt> is the appending of
--   <tt>as</tt> and <tt>bs</tt>.
--   
--   Run it with:
--   
--   <pre>
--   <a>selectTC</a> :: SingI as =&gt; Sing bs -&gt; <a>Σ</a> [k] (<a>IsAppend</a> as bs)
--   </pre>
--   
--   <a>select</a> for <a>AppendedTo</a> is pretty much just
--   <a>withAppend</a>.
type AppendedTo as = TyPP (Append as)

-- | A <tt><a>Interleave</a> as bs cs</tt> witnesses that <tt>cs</tt> is
--   <tt>as</tt> interleaved with <tt>bs</tt>. It is constructed by
--   selectively zipping items from <tt>as</tt> and <tt>bs</tt> together,
--   like mergesort or riffle shuffle.
--   
--   You construct an <a>Interleave</a> from <tt>as</tt> and <tt>bs</tt> by
--   picking "which item" from <tt>as</tt> and <tt>bs</tt> to add to
--   <tt>cs</tt>.
--   
--   Some examples:
--   
--   <pre>
--   IntL (IntL (IntR (IntR IntZ))) :: Interleave '[1,2] '[3,4] '[1,2,3,4]
--   IntR (IntR (IntL (IntL IntZ))) :: Interleave '[1,2] '[3,4] '[3,4,1,2]
--   IntL (IntR (IntL (IntR IntZ))) :: Interleave '[1,2] '[3,4] '[1,3,2,4]
--   IntR (IntL (IntR (IntL IntZ))) :: Interleave '[1,2] '[3,4] '[3,1,4,2]
--   </pre>
data Interleave :: [k] -> [k] -> [k] -> Type
[IntZ] :: Interleave '[] '[] '[]
[IntL] :: Interleave as bs cs -> Interleave (a : as) bs (a : cs)
[IntR] :: Interleave as bs cs -> Interleave as (b : bs) (b : cs)

-- | A type-level predicate that a given list is the "interleave" of
--   <tt>as</tt> and <tt>bs</tt>.
type IsInterleave as bs = TyPred (Interleave as bs)

-- | Automatically generate an <a>Interleave</a> if <tt>as</tt> and
--   <tt>bs</tt> are known statically.
autoInterleave :: forall as bs cs. Auto (IsInterleave as bs) cs => Interleave as bs cs

-- | Given two <a>Rec</a>s, interleave the two to create a combined
--   <a>Rec</a>.
interleaveRec :: Interleave as bs cs -> Rec f as -> Rec f bs -> Rec f cs

-- | Given a <a>Rec</a>, disinterleave it into two <a>Rec</a>s
--   corresponding to an <a>Interleave</a>.
unweaveRec :: Interleave as bs cs -> Rec f cs -> (Rec f as, Rec f bs)

-- | Witness an isomorphism between <a>Rec</a> and two parts that
--   interleave it.
--   
--   Read this type signature as:
--   
--   <pre>
--   <a>interleaveRecIso</a>
--       :: Interleave as  bs  cs
--       -&gt; Iso' (Rec f cs) (Rec f as, Rec f bs)
--   </pre>
--   
--   This can be used with the combinators from the lens library.
--   
--   The <a>Interleave</a> tells how to unweave the <a>Rec</a>.
interleaveRecIso :: (Profunctor p, Functor f) => Interleave as bs cs -> p (Rec g as, Rec g bs) (f (Rec g as, Rec g bs)) -> p (Rec g cs) (f (Rec g cs))

-- | Interleave an <a>Index</a> on <tt>as</tt> into a full index on
--   <tt>cs</tt>, which is <tt>as</tt> interleaved with <tt>bs</tt>.
injectIndexL :: Interleave as bs cs -> Index as a -> Index cs a

-- | Interleave an <a>Index</a> on <tt>bs</tt> into a full index on
--   <tt>cs</tt>, which is <tt>as</tt> interleaved with <tt>bs</tt>.
injectIndexR :: Interleave as bs cs -> Index bs b -> Index cs b

-- | Given an index on <tt>cs</tt>, disinterleave it into either an index
--   on <tt>as</tt> or on <tt>bs</tt>.
unweaveIndex :: Interleave as bs cs -> Index cs c -> Either (Index as c) (Index bs c)

-- | Turn an <a>Interleave</a> into a <a>Rec</a> of indices from either
--   sublist.
--   
--   Warning: O(n^2)
interleavedIxes :: Interleave as bs cs -> Rec (Index as :+: Index bs) cs

-- | Swap the two halves of an <a>Interleave</a>.
swapInterleave :: Interleave as bs cs -> Interleave bs as cs

-- | Get the <a>Shape</a>s associated with an <a>Interleave</a>.
interleaveShapes :: Interleave as bs cs -> (Shape [] as, Shape [] bs, Shape [] cs)

-- | A <tt><a>Subset</a> as bs</tt> witnesses that <tt>as</tt> is some
--   subset of <tt>bs</tt>, with items in the same order. It is constructed
--   by specifying what item to include or exclude in <tt>bs</tt> from
--   <tt>as</tt>. It is essentially <a>Interleave</a>, but without one of
--   the two initial parameters.
--   
--   You construct an <a>Subset</a> from <tt>cs</tt> by picking "which
--   item" from <tt>bs</tt> to add to <tt>as</tt>.
--   
--   Some examples:
--   
--   <pre>
--   SubsetNo  (SubsetNo  (SubsetNo  SubsetNil)) :: Subset '[]      '[1,2,3]
--   SubsetYes (SubsetNo  (SubsetNo  SubsetNil)) :: Subset '[1]     '[1,2,3]
--   SubsetNo  (SubsetNo  (SubsetYes SubsetNil)) :: Subset '[3]     '[1,2,3]
--   SubsetYes (SubsetNo  (SubsetYes SubsetNil)) :: Subset '[1,3]   '[1,2,3]
--   SubsetYes (SubsetYes (SubsetYes SubsetNil)) :: Subset '[1,2,3] '[1,2,3]
--   </pre>
data Subset :: [k] -> [k] -> Type
[SubsetNil] :: Subset '[] '[]
[SubsetNo] :: Subset as bs -> Subset as (b : bs)
[SubsetYes] :: Subset as bs -> Subset (a : as) (a : bs)

-- | A type-level predicate that a given list is a "superset" of
--   <tt>as</tt>, in correct order
type IsSubset as = TyPred (Subset as)

-- | Automatically generate an <a>Subset</a> if <tt>as</tt> and <tt>bs</tt>
--   are known statically.
autoSubset :: forall as bs. Auto (IsSubset as) bs => Subset as bs

-- | <tt>as</tt> is a subset of <tt>cs</tt>; this function recovers
--   <tt>bs</tt>, the subset of <tt>cs</tt> that is not <tt>as</tt>.
subsetComplement :: Subset as cs -> (forall bs. Subset bs cs -> r) -> r

-- | Drop the left side of an <a>Interleave</a>, leaving only the right
--   side.
interleaveRToSubset :: Interleave as bs cs -> Subset bs cs

-- | Drop the right side of an <a>Interleave</a>, leaving only the left
--   side.
interleaveLToSubset :: Interleave as bs cs -> Subset as cs

-- | Convert a <a>Subset</a> into an left <a>Interleave</a>, recovering the
--   dropped items.
subsetToInterleaveL :: Subset as cs -> (forall bs. Interleave as bs cs -> r) -> r

-- | Convert a <a>Subset</a> into an right <a>Interleave</a>, recovering
--   the dropped items.
subsetToInterleaveR :: Subset bs cs -> (forall as. Interleave as bs cs -> r) -> r

-- | A lens into a subset of a record, indicated by a <a>Subset</a>.
subsetRec :: Subset as bs -> Lens' (Rec f bs) (Rec f as)

-- | Take a subset out of a <a>Rec</a>. An alias for <tt><a>view</a>
--   (<a>subsetRec</a> s)</tt>.
getSubset :: Subset as bs -> Rec f bs -> Rec f as

-- | Get the <a>Shape</a>s associated with a <a>Subset</a>.
subsetShapes :: Subset as bs -> (Shape [] as, Shape [] bs)

-- | Get all of the indices of all the items in a <a>Subset</a>.
subsetIxes :: Subset as bs -> Rec (Index bs) as

-- | Because <tt>as</tt> is a subset of <tt>bs</tt>, an index into
--   <tt>as</tt> should also be an index into <tt>bs</tt>. This performs
--   that transformation.
--   
--   This is like a version of <a>injectIndexL</a> or <a>injectIndexR</a>,
--   for <a>Subset</a>.
weakenSubsetIndex :: Subset as bs -> Index as a -> Index bs a

-- | Because <tt>as</tt> is a subset of <tt>bs</tt>, we can
--   <i>sometimes</i> transform an index into <tt>bs</tt> into an index
--   into <tt>as</tt>. This performs that transformation. If it succeeds,
--   it means that the index in <tt>bs</tt> also exists in <tt>as</tt>;
--   otherwise, it means that the index in <tt>bs</tt> was excluded from
--   <tt>as</tt>.
--   
--   Note that if the index into <tt>a</tt> was excluded from <tt>as</tt>,
--   it doesn't necessarily mean that there is no <tt>a</tt> in <tt>bs</tt>
--   --- <tt>bs</tt> could contain a duplicate that was included into
--   <tt>as</tt>. This converts into an index to the exact same item
--   (positionlly) in the list, if it is possible.
--   
--   This is like a version of <a>unweaveIndex</a>, but for <a>Subset</a>.
strengthenSubsetIndex :: Subset as bs -> Index bs a -> Maybe (Index as a)
instance forall k (as :: [k]) (bs :: [k]). GHC.Show.Show (Data.Type.List.Sublist.Prefix as bs)
instance forall k (as :: [k]) (bs :: [k]). GHC.Show.Show (Data.Type.List.Sublist.Suffix as bs)
instance forall k (as :: [k]) (bs :: [k]) (cs :: [k]). GHC.Show.Show (Data.Type.List.Sublist.Append as bs cs)
instance forall k (as :: [k]) (bs :: [k]) (cs :: [k]). GHC.Show.Show (Data.Type.List.Sublist.Interleave as bs cs)
instance forall k (as :: [k]) (bs :: [k]). GHC.Show.Show (Data.Type.List.Sublist.Subset as bs)
instance Data.Type.Predicate.Auto.Auto (Data.Type.List.Sublist.IsSubset '[]) '[]
instance forall a (as :: [a]) (bs :: [a]) (b :: a). Data.Type.Predicate.Auto.Auto (Data.Type.List.Sublist.IsSubset as) bs => Data.Type.Predicate.Auto.Auto (Data.Type.List.Sublist.IsSubset as) (b : bs)
instance forall a1 (as :: [a1]) (bs :: [a1]) (a2 :: a1). Data.Type.Predicate.Auto.Auto (Data.Type.List.Sublist.IsSubset as) bs => Data.Type.Predicate.Auto.Auto (Data.Type.List.Sublist.IsSubset (a2 : as)) (a2 : bs)
instance forall k (as :: [k]). (Data.Singletons.Decide.SDecide k, Data.Singletons.Internal.SingI as) => Data.Type.Predicate.Decidable (Data.Type.List.Sublist.IsSubset as)
instance Data.Type.Predicate.Auto.Auto (Data.Type.List.Sublist.IsInterleave '[] '[]) '[]
instance forall a1 (as :: [a1]) (bs :: [a1]) (cs :: [a1]) (a2 :: a1). Data.Type.Predicate.Auto.Auto (Data.Type.List.Sublist.IsInterleave as bs) cs => Data.Type.Predicate.Auto.Auto (Data.Type.List.Sublist.IsInterleave (a2 : as) bs) (a2 : cs)
instance forall a (as :: [a]) (bs :: [a]) (cs :: [a]) (b :: a). Data.Type.Predicate.Auto.Auto (Data.Type.List.Sublist.IsInterleave as bs) cs => Data.Type.Predicate.Auto.Auto (Data.Type.List.Sublist.IsInterleave as (b : bs)) (b : cs)
instance forall k (as :: [k]) (bs :: [k]). (Data.Singletons.Decide.SDecide k, Data.Singletons.Internal.SingI as, Data.Singletons.Internal.SingI bs) => Data.Type.Predicate.Decidable (Data.Type.List.Sublist.IsInterleave as bs)
instance forall k (as :: [k]). Data.Singletons.Internal.SingI as => Data.Type.Predicate.Decidable (Data.Type.Predicate.Param.Found (Data.Type.List.Sublist.AppendedTo as))
instance forall k (as :: [k]). Data.Singletons.Internal.SingI as => Data.Type.Predicate.Provable (Data.Type.Predicate.Param.Found (Data.Type.List.Sublist.AppendedTo as))
instance forall k (as :: [k]). Data.Type.Predicate.Auto.Auto (Data.Type.List.Sublist.IsAppend '[] as) as
instance forall a1 (as :: [a1]) (bs :: [a1]) (cs :: [a1]) (a2 :: a1). Data.Type.Predicate.Auto.Auto (Data.Type.List.Sublist.IsAppend as bs) cs => Data.Type.Predicate.Auto.Auto (Data.Type.List.Sublist.IsAppend (a2 : as) bs) (a2 : cs)
instance forall k (as :: [k]) (bs :: [k]). (Data.Singletons.Decide.SDecide k, Data.Singletons.Internal.SingI as, Data.Singletons.Internal.SingI bs) => Data.Type.Predicate.Decidable (Data.Type.List.Sublist.IsAppend as bs)
instance forall k (as :: [k]). Data.Type.Predicate.Auto.Auto (Data.Type.List.Sublist.IsSuffix as) as
instance forall a (as :: [a]) (bs :: [a]) (b :: a). Data.Type.Predicate.Auto.Auto (Data.Type.List.Sublist.IsSuffix as) bs => Data.Type.Predicate.Auto.Auto (Data.Type.List.Sublist.IsSuffix as) (b : bs)
instance forall k (as :: [k]). (Data.Singletons.Decide.SDecide k, Data.Singletons.Internal.SingI as) => Data.Type.Predicate.Decidable (Data.Type.List.Sublist.IsSuffix as)
instance forall k (bs :: [k]). Data.Type.Predicate.Auto.Auto (Data.Type.List.Sublist.IsPrefix '[]) bs
instance forall a1 (as :: [a1]) (bs :: [a1]) (a2 :: a1). Data.Type.Predicate.Auto.Auto (Data.Type.List.Sublist.IsPrefix as) bs => Data.Type.Predicate.Auto.Auto (Data.Type.List.Sublist.IsPrefix (a2 : as)) (a2 : bs)
instance forall k (as :: [k]). (Data.Singletons.Decide.SDecide k, Data.Singletons.Internal.SingI as) => Data.Type.Predicate.Decidable (Data.Type.List.Sublist.IsPrefix as)
